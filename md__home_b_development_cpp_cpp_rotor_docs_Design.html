<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rotor: Design &amp; Notions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="extra.css" rel="stylesheet" type="text/css" />
</head>
<body>
<a href="http://www.reactivemanifesto.org/"> <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000" src="//d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-white-right.png"> </a>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rotor
   </div>
   <div id="projectbrief">Event loop friendly C++ actor micro-framework</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__home_b_development_cpp_cpp_rotor_docs_Design.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Design &amp; Notions </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><b>address</b> is runtime entity, served as subscription and delivery point. Any <code>message</code> can be sent to an address; any <code>actor</code> can subscribe on any kind of messages on any address. An <code>address</code> is generated by <code>supervisor</code>, address holds reference to <code>supervisor</code>.</p>
<p ><b>message</b> is runtime entity, which consists of destination <code>address</code> and user supplied mutable <code>payload</code>. Message are delivered to <code>actors</code>. <b>The order of delivery messages is source-actor sequenced</b>: if a source-<code>actor</code> generates messages <code>m1</code> and then <code>m2</code>, that is is guaranteed that <code>m1</code> will arrive to destination earlier then <code>m2</code>. Meanwhile there can be other messages <em>for the destination</em> from other senders. Sometimes, the approach is named <em>per-sender-FIFO</em>. The delivery itself to an actor is <em>not guaranteed</em>, not in the sense the <code>rotor</code> will loose it, but because the actor might be not yet ready for it (not subscribed), or the actor might be no longer ready for it (i.e. already unsubscribed). <code>payload</code> is <b>mutable</b>. It is user responsibility to allowed for an <code>actor</code> to change a payload in a thread-safe way, but it is recommended to do modifications only when it is known that an <code>actor</code> is single consumer of the message; if there are multiple consumers of the the messages it is recommended not to change the message, or provide synchronization mechanisms on the payload (discouraged, as locks/mutexes might lead to application deadlock).</p>
<p >The messaging in <code>rotor</code> resembles IP protocol: it is quite simple (compared to TCP), without delivery/strict delivery order guarantees, no streams, no timers etc., however solid foundation of distributed actors can be build on top of <code>rotor</code>, adding only <em>required guarantees</em>.</p>
<p ><code>rotor</code> supports <a href="https://en.wikipedia.org/wiki/Reliability_(computer_networking)" title="reliable">reliable</a> messaging via adopting <a href="https://en.wikipedia.org/wiki/Request%E2%80%93response">request-response</a> pattern: whenver <code>request</code> message is sent timeout timer is spawn, if the <code>reply</code> isn't delivered in time, the sender is notified about the occurred error. If the reply is sent twice by mistake, the second reply message will be silently discarded.</p>
<p ><b>actor</b> is runtime entity with user-defined reaction on incoming messages. An <code>actor</code> can send messages to other actors, as well as do interaction with with outer world (i.e. via loop, timers, I/O etc.). The main business-logic should be written in actors. An <code>actor</code> always is executed <em>in the context</em> of some <code>supervisor</code>.</p>
<p >Every <code>actor</code> has it's "main" address, used for rotor-internal messaging. In addition it can create as many as needed address ("identities"), which can be used for distinguishing <code>replies</code>.</p>
<p ><b>supervisor</b> is special kind of <code>actor</code>, which encapsulates <em>infrastructure-logic</em>, i.e. responsible for spawning/terminating actors, interaction with loop (timeouts), and for message dispatching/delivering. All messages sent by spawned actors, are put into outbound queue of supervisor. <code>supervisor</code> was designed to represent <em>sequential execution context</em>, similar to <code>strand</code> from [boost_asio] (in fact <code>rotor-asio</code> supervisor holds <code>strand</code> object); in other words all messages are delivered sequentially within the context of an <code>supervisor</code>, and it is safe to call one some actor's method from some other actor, located on the same supervisor, f needed.</p>
<p ><b>supervising</b> defines the supervisor reaction upon child actor shutdown. It varies from doing nothing to escalating failure (i.e. shutdown supervisor itself with all its actors, and may be its supervisor too etc) and to spawning a new actor instance again (may be, after some timeout) to give it the chance to successfully accomplish its job. <b>spawner</b> codifies different policies without a need of manually code the relevant section in supervisor.</p>
<p ><b>locality</b> is rotor-specific marker of <code>sequential execution context</code>. An supervisor might have an independent locality, i.e. execute only on its own (<code>strand</code>); or a list of supervisors might share the same <code>locality</code>. For some event loops (i.e. other then <a href="https://www.boost.org/doc/libs/release/libs/asio/" title="Boost Asio">boost_asio</a>), it it the only option. In other words it is "thread affinity" somewhat similar to <a href="https://en.wikipedia.org/wiki/Processor_affinity">cpu-affinity</a>.</p>
<p >Supervisors might form a tree-like structure making some kind of hierarchy of responsibilities. This allows to build a robust application via controlled degradation of its services when leaf-actors are restarted in case of error, then their supervisors (with all actors) are restarted and so on the error propagates until the root supervisor. The child restart policy is user-defined for each supervisor individually. For more details see the article <a href="https://basiliscos.github.io/blog/2019/08/19/cpp-supervisors/" title="Trees of Supervisors in C++">blog-cpp-supervisors</a>.</p>
<p ><img src="supervising.png" alt="supervising" class="inline"/></p>
<p >For example, if actor <code>A3</code> is going down, the <code>supervisor_child</code> will receive a message about it, and it might decide either to spawn <code>A3</code> again, or if restart limit is reached, shutdown self and all other child actors <code>A1</code> and <code>A2</code>. The <code>supervisor_root</code> will receive down message of <code>supervisor_child</code>, and the decision to restart <code>supervisor_child</code> (with all it's children) or to shutdown self should be made again.</p>
<p >Unlike supervisors in <a href="https://en.wikipedia.org/wiki/Erlang_(programming_language)">Erlang</a>, the <a href="http://wiki.c2.com/?LetItCrash">let-it-crash</a> principle is not acceptable in C++, hence it is expected that actors will perform <code>shutdown</code> procedure. It is expected that an user will inherit <code>supervisor</code> class and write application specific reaction on an actor shutdown. For proper <code>supervisor</code> destruction, all externally held <code>addresses</code> should be destroyed.</p>
<p >It should be noted, that a "crash" is actually "controlled crash", i.e. ability of an actor to detect some non-fatal error state and notify about that to upstream supervisor. After that the supervisor <em>asks</em> for shutdown and the actor must <em>confirm</em> it (maybe after some delay, i.e. after asynchronous resources release). There is no magical remedy against abnormal failures, which lead to <code>std::abort</code> or <code>std::terminate</code>.</p>
<p >The <b>system_context</b> is runtime environment for supervisors, which holds <code>loop</code> or some other context, which should be accessible in thread-safe way. When an fatal error is encounted, it is delegated to <code>system_context</code>, which by default just prints it to <code>std::cerr</code> and invokes <code>std::abort()</code>.</p>
<p >All <code>rotor</code> entities above use <em>intrusive pointer</em> approach from <a href="https://www.boost.org/doc/libs/release/libs/smart_ptr/" title="Boost Smart Pointers">boost-smartptr</a>, with the thread-safe atomic counters by default. If it is known, that <code>rotor</code> actors will be used strictly on single thread, then it is possible to use faster non-atomic counters.</p>
<h1>Actor lifecycle</h1>
<p ><img src="lifecycle-simplified.png" alt="lifetime-simplified" class="inline"/></p>
<p >The simplified actor lifetime is shown on the picture above. When actor is ready, it enters into <code>operational</code> state, providing its services (i.e. starting to react on the incoming messages).</p>
<p >The <code>init</code> and <code>shut down</code> actor states are similar to constructor and destructor for an object, with one noteable exception: they are <em>asynchronous</em>. If <code>init</code> fails, an actor does not enters into <code>operational</code> state and starts to shut down.</p>
<p ><img src="lifecycle-full.png" alt="lifetime-full" class="inline"/></p>
<p >The real world actor lifecycle is a little bit more complicated. The freshly instantiated actor is in <code>NEW</code> state; it does not receives any messages. In the <code>INITIALIZING</code> state it starts plugins initialization, they subscribe to system (rotor) messages and do other init activities, including the user ones.</p>
<p >When init is finished (i.e. all plugins confirmed they are done with initialization), an actor enters into <code>INITIALIZED</code> state. It is already subscribed to all required user messages and ready to serve; however, it still can wait an signal to start from it supervisor to perform some action on demand, and only then the actor enters into <code>OPERATIONAL</code> state. The signal does not have to come: supervisor might postpone it (see synchronization patterns) or do not send at all, asking to shutdown (because it was asked by its parent supervisor or some sibling actor failed to init).</p>
<p >The shutdown is procedure is reverse: in <code>SHUTTING_DOWN</code> state actor unsubscribes from all user and system messages, releases resources etc., and when it is done, it enters into <code>SHUT_DOWN</code> state. In that state it does not receives any messages and sooner it will be destroyed.</p>
<p >It is possible to hook corresponding methods from <code>actor_base_t</code> (please note, that the <code>actor_base_t</code> methods <em>must</em> be called when overriding):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> actor_base_t::init_start()      <span class="comment">// NEW           -&gt; INITIALIZING</span></div>
<div class="line">void actor_base_t::init_finish()     <span class="comment">// INITIALIZING  -&gt; INITIALIZED</span></div>
<div class="line"><span class="keywordtype">void</span> actor_base_t::on_start()        <span class="comment">// INITIALIZED   -&gt; OPERATIONAL</span></div>
<div class="line"><span class="keywordtype">void</span> actor_base_t::shutdown_start()  <span class="comment">// OPERATIONAL   -&gt; SHUTTING_DOWN</span></div>
<div class="line"><span class="keywordtype">void</span> actor_base_t::shutdown_finish() <span class="comment">// SHUTTING_DOWN -&gt; SHUT_DOWN</span></div>
</div><!-- fragment --><p >The state transitioning is usually performed via sending and receiving appropriate messages, e.g. a supervisor sends to an actor <code>message::initialize_actor_t</code> <b>request</b> and the actor enters into <code>INITIALIZING</code> state; when it switches to <code>INITIALIZED</code> at state the actor sends back the initialization confirmation. That details are hidden from user since <code>v0.09</code>.</p>
<p ><b>Supervisor</b> is an actor, so it has exactly the same lifecycle. It has the peculiarity, that it waits it's children, i.e. supervisor enters into <code>INITIALIZING</code> state before any of it's children actors, then it waits until all of its childern confirm that they are <code>INITIALIZED</code>, and only after that the supervisor confirms that its own initialization is accomplished (the similar procedure is done for shutdown procedure).</p>
<p >That reveals very important property of an actor lifecycle - it is <b>composeable</b>. In a simple words it can be explained as the following: it makes it possible that whole tree (hierarchy) of actors and supervisors either becames ready (<code>OPERATIONAL</code>) or not (<code>SHUT DOWN</code>) without any special intervention from a user.</p>
<p >What makes it distinguishing supervisors from actors? It is the mechanism of plugins.</p>
<h1>Plugins</h1>
<p >Plugins were introduced in <code>v0.09</code> to replace actors behavior, because behavior nor actor itself can <em>authoritatively</em> answer the question whether the initialization (shutdown) is done, because there are a lot of factors with different natures, which affect the answer: are system subscriptions done? are user subscriptions done? are all child actors confirmed initialization? are all acquired external resources already released? The answer should be committed <em>cooperatively</em> and the single vote in the role of a plugin. If a plugin says "I'm still not yet done with initialization", then the whole actor still holds the <code>INITIALIZING</code> state; if a plugin says "I'm failed to initialize", the whole actor state jumps into shutdown phase.</p>
<p >Each actor has a static (compile-time) list of plugins. They are polled for init-ready question in the direct order, and for shutdown-ready question in the reverse order. Once a plugin says "I'm done", the next one is polled etc.</p>
<p >The most important for user actor plugins are:</p>
<div class="fragment"><div class="line">plugin::link_client_plugin_t</div>
<div class="line">plugin::registry_plugin_t</div>
<div class="line">plugin::resources_plugin_t</div>
</div><!-- fragment --><p >The <code>link_client</code> plugin is response for linking the current actor ("client" role) with an other actor(s) ("server(s)"). This can be seen as "virtual TCP-connection", i.e. making sure that "server" will outlive "client", i.e. all messages from "client" to "server" will be eventually delivered, i.e. "server" will not spontaneously shut self down having alive client connected to it. The "server" have to confirm successful linkig of a "client", while "client" waiting the response confirmation suspends its own initialization (i.e its state is <code>INITIALIZING</code>). It should be noted, that actors linking is performed by actor addresses only, i.e. "client" and "server" actors might belong to different threads, supervisors, localities or event loops.</p>
<p >The <code>registry</code> plugin is the continued development of the <code>link_client</code> plugin. It allows for "server" to register self in the "registry" (special actor, shipped with <code>rotor</code>), and for "client" to discover "server" address via some symbolic name (string) and then link to it (using, <code>link_client</code>, of course). This makes it possible to encapsulate actors dependencies (i.e. to work I need "servcieA" and "serviceB") as well as export actors services (i.e. once I'm working I provide "serviceC").</p>
<p >The <code>resources</code> plugin is very specific one, as it allows to actor know that to continue initialization (or shutdown) it needs to acquire/release external (non-<code>rotor</code>) resources. For example, it covers the cases like: "before my actor
starts, it needs to open TCP connector to remote side and perform successful
authorization", i.e. it suspends initialization (shutdown) until some external events occur.</p>
<h1>Miscellaneous topics</h1>
<h2>Contract and its violation</h2>
<p >It is absolutely correct to <b>fail initialization</b> because an actor will be asked to shutdown, probably with up-scaling the problem; however <b>fail shutdown</b> for <code>rotor</code> is violation of the contract, similar to an exception in destructor in C++. What can the micro framework do in that situation? Out of the box it delegates the issue to the <code>system_context_t</code> which default implementation is to print the error and invoke <code>std::termiate</code>.</p>
<p >You can override the <code>on_error</code> method and hope, that it will continue to work. The most likely it will, however, there will be a memory leak. The <em>rotor part</em> of the leak in the failed to shutdown actor still can be handled via cleaning internal rotor resources (see <code>tests/actor_test.cpp</code> the <code>force_cleanup()</code> method how to do that). Still the most likely there are non-rotor leaked resources, which have to be released too. So, if you are routing this way, you are on very very very shaky ground near UB, and the advice not to go here at all.</p>
<p >If a client-actor refuses to <code>unlink</code> in time, when server-actor asked it (because it was asked to shut down), it is also violation of the contract.</p>
<p >If you meeting the issue, you should tune (shutdown) timeouts for your actors to give them enough breath to finish activities they are doing. For example, as the (parent) supervisor shutdowns after all its children are shut down, then the parent supervisor shutdown timeout <em>should be greater</em> then the corresponding timeout of any of its children. Probably, the easiest way to start is to use everywhere some fixed, but large enough, timeout (e.g. <code>100ms</code>) everywhere, and only later, if the problem occurs, tune individual timeouts on demand. Another technique for dealing with non-rotor asynchronous resources, is to spawn additional timer at <code>shutdown_start</code> and cancel all non-rotor I/O or move and send them to some other actor, which can deal with that.</p>
<p >It is recommended to launch code under memory sanitizer tool like <code>valgrind</code> to make sure everything is correctly cleaned. This relates to program shutdown too.</p>
<h2>Debugging messaging</h2>
<p >To see the messages traffic in <em>non-release</em> build, the special environment variable <code>ROTOR_INSPECT_DELIVERY=1</code> should be used. The <code>delivery</code> plugin will dump messages routing via a supervisor. Here is an excerpt:</p>
<div class="fragment"><div class="line">&gt;&gt; rotor::message_t&lt;rotor::payload::subscription_confirmation_t&gt; [P] m: rotor::message_t&lt;rotor::payload::unsubscription_confirmation_t&gt;, addr: 0x5567c50db770  for 0x5567c50db770</div>
<div class="line">&gt;&gt; rotor::message_t&lt;rotor::payload::subscription_confirmation_t&gt; [P] m: rotor::message_t&lt;rotor::payload::external_unsubscription_t&gt;, addr: 0x5567c50db770  for 0x5567c50db770</div>
<div class="line">&gt;&gt; rotor::message_t&lt;rotor::payload::subscription_confirmation_t&gt; [P] m: rotor::message_t&lt;rotor::payload::subscription_confirmation_t&gt;, addr: 0x5567c50db770  for 0x5567c50db770</div>
<div class="line">&gt;&gt; rotor::message_t&lt;rotor::payload::subscription_confirmation_t&gt; [P] m: rotor::message_t&lt;rotor::wrapped_request_t&lt;rotor::payload::initialize_actor_t, void&gt; &gt;, addr: 0x5567c50db770  for 0x5567c50db770</div>
<div class="line">...</div>
</div><!-- fragment --><p >If you need something more custom, then a new delivery plugin should be developed, and then it should be linked into new supervisor type.</p>
<h2>Non-public properties access</h2>
<p >To have everything public is bad, as some fields and methods are not part of public interface. Still sometimes there is a need to access them outside, e.g. in tests. Provide getters and setters for all of them seems also incorrect, again, because they are not part of public interface.</p>
<p >Since <code>v0.09</code> the experimental templated <code>access()</code> method was added to handle that rare cases. It is assumed, that you'll add your own partial specialization of the method, which will grant access to the required fields or methods.</p>
<p >For further details, please consult an <a href="https://basiliscos.github.io/blog/2020/07/23/permission-model/" title="C++ permission model">article</a> in my blog.</p>
<h2>Actor (configuration) builder</h2>
<p >Since <code>v0.09</code> every actor (including supervisors) should have a config. It is just a plain <code>struct</code> with the minimal set of properties like: init and shutdown timeouts, parent supervisor pointer etc.</p>
<p >However, it is not handy to deal with plain <code>struct</code>, especially if there are aliases and optional fields. That's why dedicated <code>config_builder_t</code> was introduced to mark that some required fields have been filled and other convenient things like actor instantiation.</p>
<p >To cover the cases, when any <em>derived</em> actor/config can have custom properties, the <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curiously recurring template pattern aka CRTP pattern</a> was used. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
