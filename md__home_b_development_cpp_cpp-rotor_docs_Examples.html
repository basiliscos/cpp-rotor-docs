<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rotor: Advanced examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="extra.css" rel="stylesheet" type="text/css" />
</head>
<body>
<a href="http://www.reactivemanifesto.org/"> <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000" src="//d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-white-right.png"> </a>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rotor
   </div>
   <div id="projectbrief">Event loop friendly C++ actor micro-framework</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_b_development_cpp_cpp-rotor_docs_Examples.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Advanced examples </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>ping-pong example</h1>
<p>The full source code can be seen at <a href="https://github.com/basiliscos/cpp-rotor/blob/master/examples/boost-asio/ping-pong-timer.cpp">examples/boost-asio/ping-pong-timer.cpp</a>.</p>
<p>We would like to get some ping-pong system. There are enough examples of simple ping-pong messaging, however here we'd like to <b>simulate unreliability of I/O</b> via the ping-pong and the toolset, available in <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>, to overcome the unreliability.</p>
<p>The sources of the unreliability are: a) the <code>pong</code> response message does not arrive in time; b) error happens in I/O layer. The additional requirement will be c) to allow the entire system to do clean shutdown at any time, e.g. on user press <code>CTRL+C</code> on terminal.</p>
<p>Let enumerate the <b>rules of the simulator</b>. To simulate the unreliability, let's assume that <code>ponger</code> actor will answer not immediately upon <code>ping</code> request, but after some time and with some probability. "After some time" means that sometimes it will respond in time, and sometimes too late. The "some probability" will simulate I/O errors. As soon as <code>pinger</code> receives successful <code>pong</code> response it shuts down the entire simulator. However, if the <code>pinger</code> actor does not receive any successful <code>pong</code> response during some time despite multiple attempts, it should shut self down too. The rules are reified as the constants like:</p>
<div class="fragment"><div class="line">namespace constants {</div>
<div class="line">static float failure_probability = 0.97f;</div>
<div class="line">static pt::time_duration ping_timeout = pt::milliseconds{100};</div>
<div class="line">static pt::time_duration ping_reply_base = pt::milliseconds{50};</div>
<div class="line">static pt::time_duration check_interval = pt::milliseconds{3000};</div>
<div class="line">static std::uint32_t ping_reply_scale = 70;</div>
<div class="line">} // namespace constants</div>
</div><!-- fragment --><p>The <code>pinger</code> pings ponger during <code>check_interval</code> or shuts self down. The ponger generates response during <code>50 + rand(70)</code> milliseconds with the <code>1 - failure_probability</code>.</p>
<p>Ok, let's go to the implementation. To make it reliable, we are going to use many patterns, but first of all, let's use the <a href="https://basiliscos.github.io/blog/2019/10/05/request-response-message-exchange-pattern/">request-response</a> one:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>payload {</div>
<div class="line"><span class="keyword">struct </span>pong_t {};</div>
<div class="line"><span class="keyword">struct </span>ping_t {</div>
<div class="line">    <span class="keyword">using</span> response_t = pong_t;</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// namespace payload</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message {</div>
<div class="line"><span class="keyword">using</span> ping_t = <a class="code" href="structrotor_1_1message__t.html">rotor::request_traits_t&lt;payload::ping_t&gt;::request::message_t</a>;</div>
<div class="line"><span class="keyword">using</span> pong_t = <a class="code" href="structrotor_1_1message__t.html">rotor::request_traits_t&lt;payload::ping_t&gt;::response::message_t</a>;</div>
<div class="line"><span class="keyword">using</span> cancel_t = <a class="code" href="structrotor_1_1message__t.html">rotor::request_traits_t&lt;payload::ping_t&gt;::cancel::message_t</a>;</div>
<div class="line">} <span class="comment">// namespace message</span></div>
</div><!-- fragment --><p>Since the <code>v0.10</code> it is possible to cancel pending requests in <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>. Second pattern will be the <code>discovery</code> (registry) pattern: here the <code>ponger_t</code> actor will act as a server (i.e. it will announce self in a registry), and the <code>pinger_t</code> actor will act as a client, (i.e. it will locate <code>ponger</code> in a registry by name):</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>pinger_t : <span class="keyword">public</span> <a class="code" href="structrotor_1_1actor__base__t.html">rotor::actor_base_t</a> {</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="structrotor_1_1actor__base__t.html#a1c7143d733572600a355d8bcb02367bc">configure</a>(<a class="code" href="structrotor_1_1plugin_1_1plugin__base__t.html">rotor::plugin::plugin_base_t</a> &amp;plugin) noexcept <span class="keyword">override</span> {</div>
<div class="line">        ...</div>
<div class="line">        plugin.with_casted&lt;<a class="code" href="structrotor_1_1plugin_1_1registry__plugin__t.html">rotor::plugin::registry_plugin_t</a>&gt;(</div>
<div class="line">            [&amp;](<span class="keyword">auto</span> &amp;p) { p.discover_name(<span class="stringliteral">&quot;ponger&quot;</span>, ponger_addr, <span class="keyword">true</span>).link(); });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>ponger_t : <span class="keyword">public</span> <a class="code" href="structrotor_1_1actor__base__t.html">rotor::actor_base_t</a> {</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordtype">void</span> configure(<a class="code" href="structrotor_1_1plugin_1_1plugin__base__t.html">rotor::plugin::plugin_base_t</a> &amp;plugin) noexcept <span class="keyword">override</span> {</div>
<div class="line">        ...</div>
<div class="line">        plugin.with_casted&lt;<a class="code" href="structrotor_1_1plugin_1_1registry__plugin__t.html">rotor::plugin::registry_plugin_t</a>&gt;(</div>
<div class="line">            [&amp;](<span class="keyword">auto</span> &amp;p) { p.register_name(<span class="stringliteral">&quot;ponger&quot;</span>, get_address()); });</div>
<div class="line">    }</div>
</div><!-- fragment --><p>The mediator (aka registry) actor have to be created; we'll instruct supervisor to instantiate it for us:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> sup = system_context-&gt;create_supervisor&lt;custom_supervisor_t&gt;()</div>
<div class="line">               ...</div>
<div class="line">               .create_registry()</div>
<div class="line">               ...</div>
<div class="line">               .finish();</div>
</div><!-- fragment --><p>What should <code>pinger</code> do upon start? It should do <code>ping</code> ponger and spawn a timer to shut self down upon timeout.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> on_start() noexcept<span class="keyword"> override </span>{</div>
<div class="line">    <a class="code" href="structrotor_1_1actor__base__t.html#abd09068676677472caabe32ed7ef7aaf">rotor::actor_base_t::on_start</a>();</div>
<div class="line">    do_ping();</div>
<div class="line"> </div>
<div class="line">    timer_id = start_timer(constants::check_interval, *<span class="keyword">this</span>, &amp;pinger_t::on_custom_timeout);</div>
<div class="line">    resources-&gt;acquire(resource::timer);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> on_custom_timeout(<a class="code" href="namespacerotor.html#aa709f45800c1bc7ea4d7bb2163328b4c">rotor::request_id_t</a>, <span class="keywordtype">bool</span> cancelled) {</div>
<div class="line">    resources-&gt;release(resource::timer);</div>
<div class="line">    timer_id.reset();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;pinger_t (&quot;</span> &lt;&lt; (<span class="keywordtype">void</span> *)<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;), on_custom_timeout, cancelled: &quot;</span> &lt;&lt; cancelled &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (!cancelled) {</div>
<div class="line">        do_shutdown();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>on_start</code> method is rather trivial, except the two nuances. First, it must record the <code>timer_id</code>, which may be necessary for the timer cancellation on shutdown initiation. Second, it acquires the timer <em>resource</em>, whose entire purpose is to delay shutdown (and, in general, the initialization) phase. Without the resource acquisition, the timer might trigger <em>after</em> actor shutdown, which usually is bad idea. In the timer handler (<code>on_custom_timeout</code>) it performs the reverse actions: the timer <em>resource</em> is released (and, hence, shutdown will be continued if it was started), and <code>timer_id</code> is reset to prevent cancellation in shutdown (will be shown soon). There is a guarantee, that timer handler will be invoked once anyway, whether it was cancelled or triggered. However, in accordance with our rules if it triggers, the <code>pinger</code> actor should shut self down (i.e. <code>do_shutdown()</code> method is invoked).</p>
<p>Let's demonstrate the <code>pinger</code> shutdown procedure:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> shutdown_start() noexcept<span class="keyword"> override </span>{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;pinger_t, (&quot;</span> &lt;&lt; (<span class="keywordtype">void</span> *)<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;) shutdown_start() \n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (request_id)</div>
<div class="line">        send&lt;message::cancel_t&gt;(ponger_addr, get_address());</div>
<div class="line">    <span class="keywordflow">if</span> (timer_id) {</div>
<div class="line">        cancel_timer(*timer_id);</div>
<div class="line">        timer_id.reset();</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="structrotor_1_1actor__base__t.html#af559ff2601f0b0d4ed2f678c9cf701d1">rotor::actor_base_t::shutdown_start</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>It's quite trivial: if there is a pending ping request, let's cancel it. If there is an active timer, let's cancel it too. Otherwise, let's continue shutdown. It should be noted, that the acquired resources are not released here; instead of the corresponding async operations are cancelled, and the resources will be released upon cancellation. The <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> internals knows about resources, so, it is safe to invoke <code><a class="el" href="structrotor_1_1actor__base__t.html#af559ff2601f0b0d4ed2f678c9cf701d1" title="starts shutdown procedure, e.g. upon receiving shutdown request">rotor::actor_base_t::shutdown_start()</a></code> here (and it should). Any further resource release will continue suspended shutdown or initialization (see more about that in <code><a class="el" href="structrotor_1_1plugin_1_1resources__plugin__t.html" title="&quot;lock&quot; for external resources">rotor::plugin::resources_plugin_t</a></code>).</p>
<p>Let's see the ping request and reaction to ping response (<code>pong</code>) in <code>pinger</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> do_ping() noexcept {</div>
<div class="line">    resources-&gt;acquire(resource::ping);</div>
<div class="line">    request_id = request&lt;payload::ping_t&gt;(ponger_addr).send(constants::ping_timeout);</div>
<div class="line">    ++attempts;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> on_pong(message::pong_t &amp;msg) noexcept {</div>
<div class="line">    resources-&gt;release(resource::ping);</div>
<div class="line">    request_id.reset();</div>
<div class="line">    <span class="keyword">auto</span> &amp;ec = msg.payload.ec;</div>
<div class="line">    <span class="keywordflow">if</span> (!ec) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;pinger_t, (&quot;</span> &lt;&lt; (<span class="keywordtype">void</span> *)<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;) success!, pong received, attemps : &quot;</span> &lt;&lt; attempts &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        do_shutdown();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;pinger_t, (&quot;</span> &lt;&lt; (<span class="keywordtype">void</span> *)<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;) pong failed (&quot;</span> &lt;&lt; attempts &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (timer_id) {</div>
<div class="line">            do_ping();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Again, it follows the same pattern: initiate async operation (request), acquire resource, record it; and, upon response, release the resource, forget the request. Upon shutdown (as it is shown above), cancel request if it exists. As for the request processing flow, according to our rules, it shuts self down upon successful pong response; otherwise, if the actor is still operational (i.e. <code>timer_id</code> does exist), it performs another ping attempt.</p>
<p>Let's move the <code>ponger</code> overview. As the actor plays the server role it usually does not have <code>on_start()</code> method. As <code>ponger</code> does not reply immediately to ping requests, it should store them internally for further responses.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ponger_t : <span class="keyword">public</span> <a class="code" href="structrotor_1_1actor__base__t.html">rotor::actor_base_t</a> {</div>
<div class="line">    ...;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacerotor.html#a0196761fe474bd8dc17ac4ff9f0e2f95">message_ptr_t</a> = <a class="code" href="namespacerotor.html#ae1d5cfad16ceed2d6891721ffb47c7e2">rotor::intrusive_ptr_t&lt;message::ping_t&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> requests_map_t = std::unordered_map&lt;rotor::request_id_t, message_ptr_t&gt;;</div>
<div class="line">    ...</div>
<div class="line">    requests_map_t requests;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The key moment in the <code>requests_map_t</code> is <code><a class="el" href="namespacerotor.html#aa709f45800c1bc7ea4d7bb2163328b4c" title="timer identifier type in the scope of the actor">rotor::request_id_t</a></code>, which represents timer for each delayed ping response. So, when ping request arrives, timer is spawned and stored with the smart pointer to the original request:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> on_ping(message::ping_t &amp;req) noexcept {</div>
<div class="line">    <span class="keywordflow">if</span> (state != rotor::state_t::OPERATIONAL) {</div>
<div class="line">        <span class="keyword">auto</span> ec = <a class="code" href="namespacerotor.html#a19351d6ef5d9f14c2a558df319ddbf76">rotor::make_error_code</a>(rotor::error_code_t::cancelled);</div>
<div class="line">        reply_with_error(req, ec);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">auto</span> timer_id = start_timer(reply_after, *<span class="keyword">this</span>, &amp;ponger_t::on_ping_timer);</div>
<div class="line">    resources-&gt;acquire(resource::timer);</div>
<div class="line">    requests.emplace(timer_id, <a class="code" href="namespacerotor.html#a0196761fe474bd8dc17ac4ff9f0e2f95">message_ptr_t</a>(&amp;req));</div>
<div class="line">}</div>
</div><!-- fragment --><p>As usual with async operations, the timer resource is acquired. However, there is additional check for the actor state, as we don't want even to start asyns operation (timer), when actor is shutting down; in case actor replies immediately with error.</p>
<p>The timer handler implementation isn't difficult:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> on_ping_timer(<a class="code" href="namespacerotor.html#aa709f45800c1bc7ea4d7bb2163328b4c">rotor::request_id_t</a> timer_id, <span class="keywordtype">bool</span> cancelled) noexcept {</div>
<div class="line">    resources-&gt;release(resource::timer);</div>
<div class="line">    <span class="keyword">auto</span> it = requests.find(timer_id);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!cancelled) {</div>
<div class="line">        <span class="keyword">auto</span> dice = dist(gen);</div>
<div class="line">        <span class="keywordflow">if</span> (dice &gt; constants::failure_probability) {</div>
<div class="line">            <span class="keyword">auto</span> &amp;msg = it-&gt;second;</div>
<div class="line">            reply_to(*msg);</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keyword">auto</span> ec = <a class="code" href="namespacerotor.html#a19351d6ef5d9f14c2a558df319ddbf76">rotor::make_error_code</a>(rotor::error_code_t::cancelled);</div>
<div class="line">        reply_with_error(*it-&gt;second, ec);</div>
<div class="line">    }</div>
<div class="line">    requests.erase(it);</div>
</div><!-- fragment --><p>In other words, if the timer isn't cancelled, it <em>may be</em> replied with success, or, if it was cancelled it replies with corresponding error code. Again, the timer resource is released, and request is erased from the requests map. Actually, it can be implemented in a little bit more verbose way: respond with error upon unsuccessful dice roll; however this is <em>not necessary</em>, due to the request-response pattern it is protected by timer on the request side (i.e. in <code>pinger</code>).</p>
<p>Nonetheless it <b>does response with error</b> in the case of the cancellation, because the cancellation usually happens during shutdown procedure, which it is desirable to finish ASAP, otherwise the shutdown timer will trigger, and, by default, it will call <code>std::terminate</code>. That can be worked around via tuning the shutdown timeouts (i.e. to let shutdown timeout be greater than the request timeout), however, it is rather shaky ground and it is not recommended to follow.</p>
<p>The cancellation implementation is rather straightforward: it finds the timer/request pair by the the original request id and origin (actor address), and then cancels the found timer. It should be noted, that timer might have already been triggered and, hence, it is not found in the request map.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> on_cancel(message::cancel_t &amp;notify) noexcept {</div>
<div class="line">    <span class="keyword">auto</span> request_id = notify.payload.id;</div>
<div class="line">    <span class="keyword">auto</span> &amp;source = notify.payload.source;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;cancellation notify\n&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> predicate = [&amp;](<span class="keyword">auto</span> &amp;it) {</div>
<div class="line">        <span class="keywordflow">return</span> it.second-&gt;payload.id == request_id &amp;&amp; it.second-&gt;payload.origin == source;</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">auto</span> it = std::find_if(requests.begin(), requests.end(), predicate);</div>
<div class="line">    <span class="keywordflow">if</span> (it != requests.end()) {</div>
<div class="line">        cancel_timer(it-&gt;first);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>ponger</code> shutdown procedure is trivial: it just cancels all pending ping responses; responces are deleted during cancellation callback invocation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> shutdown_start() noexcept<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keywordflow">while</span> (!requests.empty()) {</div>
<div class="line">        <span class="keyword">auto</span> &amp;timer_id = requests.begin()-&gt;first;</div>
<div class="line">        cancel_timer(timer_id);</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="structrotor_1_1actor__base__t.html#af559ff2601f0b0d4ed2f678c9cf701d1">rotor::actor_base_t::shutdown_start</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The final piece in the example is a custom supervisor:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>custom_supervisor_t : ra::supervisor_asio_t {</div>
<div class="line">    <span class="keyword">using</span> ra::supervisor_asio_t::supervisor_asio_t;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> on_child_shutdown(actor_base_t *, <span class="keyword">const</span> std::error_code &amp;) noexcept <span class="keyword">override</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (state &lt; rotor::state_t::SHUTTING_DOWN) {</div>
<div class="line">            do_shutdown();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> shutdown_finish() noexcept<span class="keyword"> override </span>{</div>
<div class="line">        ra::supervisor_asio_t::shutdown_finish();</div>
<div class="line">        strand-&gt;context().stop();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>What is the need of it? First, because as for our rules, when <code>pinger</code> shuts down, the entire system should shutdown too (Out of the box, in <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> a supervisor automatically shut self down only if it's child has been shut down, while <em>the supervisor itself is in initialization stage</em>). Second, it should stop boost::asio event loop and exit from <code>main()</code> function.</p>
<p>That it is. In my opinion it has moderate complexity, however the clean shutdown <b>scales well</b>, if every actor has clean shutdown. And here is the demonstration of the thesis: you can add many ping clients, and it still performs correctly the main logic as well as the clean shutdown. That can be checked with tools like valgrind or memory/UB-sanitizers etc.</p>
<p>The output samples:</p>
<div class="fragment"><div class="line">(all ping failed)</div>
<div class="line">./examples/boost-asio/ping-pong-timer</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (1)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (2)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (3)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (4)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (5)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (6)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (7)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (8)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (9)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (10)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (11)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (12)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (13)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (14)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (15)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (16)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (17)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (18)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (19)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (20)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (21)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (22)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (23)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (24)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (25)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (26)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (27)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (28)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (29)</div>
<div class="line">pinger_t, (0x556d13bbd8a0), on_custom_timeout, cancelled: 0</div>
<div class="line">pinger_t, (0x556d13bbd8a0) shutdown_start()</div>
<div class="line">pinger_t, (0x556d13bbd8a0) pong failed (30)</div>
<div class="line">pinger_t, (0x556d13bbd8a0) finished attempts done 30</div>
<div class="line">ponger_t, shutdown_finish</div>
<div class="line"> </div>
<div class="line">(11-th ping was successful)</div>
<div class="line">./examples/boost-asio/ping-pong-timer</div>
<div class="line">pinger_t, (0x55f9f90048a0) pong failed (1)</div>
<div class="line">pinger_t, (0x55f9f90048a0) pong failed (2)</div>
<div class="line">pinger_t, (0x55f9f90048a0) pong failed (3)</div>
<div class="line">pinger_t, (0x55f9f90048a0) pong failed (4)</div>
<div class="line">pinger_t, (0x55f9f90048a0) pong failed (5)</div>
<div class="line">pinger_t, (0x55f9f90048a0) pong failed (6)</div>
<div class="line">pinger_t, (0x55f9f90048a0) pong failed (7)</div>
<div class="line">pinger_t, (0x55f9f90048a0) pong failed (8)</div>
<div class="line">pinger_t, (0x55f9f90048a0) pong failed (9)</div>
<div class="line">pinger_t, (0x55f9f90048a0) pong failed (10)</div>
<div class="line">pinger_t, (0x55f9f90048a0) success!, pong received, attemps : 11</div>
<div class="line">pinger_t, (0x55f9f90048a0) shutdown_start()</div>
<div class="line">pinger_t, (0x55f9f90048a0), on_custom_timeout, cancelled: 1</div>
<div class="line">pinger_t, (0x55f9f90048a0) finished attempts done 11</div>
<div class="line">ponger_t, shutdown_finish</div>
<div class="line"> </div>
<div class="line">(premature termination via CTRL+C pressing)</div>
<div class="line">./examples/boost-asio/ping-pong-timer</div>
<div class="line">pinger_t, (0x55d5d95d98a0) pong failed (1)</div>
<div class="line">pinger_t, (0x55d5d95d98a0) pong failed (2)</div>
<div class="line">pinger_t, (0x55d5d95d98a0) pong failed (3)</div>
<div class="line">pinger_t, (0x55d5d95d98a0) pong failed (4)</div>
<div class="line">pinger_t, (0x55d5d95d98a0) pong failed (5)</div>
<div class="line">pinger_t, (0x55d5d95d98a0) pong failed (6)</div>
<div class="line">^Cpinger_t, (0x55d5d95d98a0) shutdown_start()</div>
<div class="line">pinger_t, (0x55d5d95d98a0), on_custom_timeout, cancelled: 1</div>
<div class="line">pinger_t, (0x55d5d95d98a0) pong failed (7)</div>
<div class="line">pinger_t, (0x55d5d95d98a0) finished attempts done 7</div>
<div class="line">ponger_t, shutdown_finish</div>
</div><!-- fragment --><p>The full source code can be seen at <a href="https://github.com/basiliscos/cpp-rotor/blob/master/examples/boost-asio/ping-pong-timer.cpp">examples/boost-asio/ping-pong-timer.cpp</a>. There is a more advanced <a href="https://github.com/basiliscos/cpp-rotor/blob/master/examples/boost-asio/beast-scrapper.cpp">examples/boost-asio/beast-scrapper.cpp</a> example too, however without detailed explanations. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="astructrotor_1_1plugin_1_1registry__plugin__t_html"><div class="ttname"><a href="structrotor_1_1plugin_1_1registry__plugin__t.html">rotor::plugin::registry_plugin_t</a></div><div class="ttdoc">handy access to registry_t, for name registration and discovery</div><div class="ttdef"><b>Definition:</b> registry.h:29</div></div>
<div class="ttc" id="anamespacerotor_html_a0196761fe474bd8dc17ac4ff9f0e2f95"><div class="ttname"><a href="namespacerotor.html#a0196761fe474bd8dc17ac4ff9f0e2f95">rotor::message_ptr_t</a></div><div class="ttdeci">intrusive_ptr_t&lt; message_base_t &gt; message_ptr_t</div><div class="ttdoc">intrusive pointer for message</div><div class="ttdef"><b>Definition:</b> message.h:68</div></div>
<div class="ttc" id="anamespacerotor_html_aa709f45800c1bc7ea4d7bb2163328b4c"><div class="ttname"><a href="namespacerotor.html#aa709f45800c1bc7ea4d7bb2163328b4c">rotor::request_id_t</a></div><div class="ttdeci">std::size_t request_id_t</div><div class="ttdoc">timer identifier type in the scope of the actor</div><div class="ttdef"><b>Definition:</b> forward.hpp:33</div></div>
<div class="ttc" id="anamespacerotor_html_a19351d6ef5d9f14c2a558df319ddbf76"><div class="ttname"><a href="namespacerotor.html#a19351d6ef5d9f14c2a558df319ddbf76">rotor::make_error_code</a></div><div class="ttdeci">std::error_code make_error_code(error_code_t e)</div><div class="ttdoc">makes std::error_code from rotor error_code enumerations</div><div class="ttdef"><b>Definition:</b> error_code.h:42</div></div>
<div class="ttc" id="astructrotor_1_1actor__base__t_html_abd09068676677472caabe32ed7ef7aaf"><div class="ttname"><a href="structrotor_1_1actor__base__t.html#abd09068676677472caabe32ed7ef7aaf">rotor::actor_base_t::on_start</a></div><div class="ttdeci">virtual void on_start() noexcept</div><div class="ttdoc">actor is fully initialized and it's supervisor has sent signal to start</div></div>
<div class="ttc" id="astructrotor_1_1plugin_1_1plugin__base__t_html"><div class="ttname"><a href="structrotor_1_1plugin_1_1plugin__base__t.html">rotor::plugin::plugin_base_t</a></div><div class="ttdoc">base class for all actor plugins</div><div class="ttdef"><b>Definition:</b> plugin_base.h:21</div></div>
<div class="ttc" id="astructrotor_1_1actor__base__t_html_a1c7143d733572600a355d8bcb02367bc"><div class="ttname"><a href="structrotor_1_1actor__base__t.html#a1c7143d733572600a355d8bcb02367bc">rotor::actor_base_t::configure</a></div><div class="ttdeci">virtual void configure(plugin::plugin_base_t &amp;plugin) noexcept</div><div class="ttdoc">main callback for plugin configuration when it's ready</div></div>
<div class="ttc" id="astructrotor_1_1actor__base__t_html"><div class="ttname"><a href="structrotor_1_1actor__base__t.html">rotor::actor_base_t</a></div><div class="ttdoc">universal primitive of concurrent computation</div><div class="ttdef"><b>Definition:</b> actor_base.h:41</div></div>
<div class="ttc" id="astructrotor_1_1message__t_html"><div class="ttname"><a href="structrotor_1_1message__t.html">rotor::message_t</a></div><div class="ttdoc">the generic message meant to hold user-specific payload</div><div class="ttdef"><b>Definition:</b> message.h:50</div></div>
<div class="ttc" id="anamespacerotor_html_ae1d5cfad16ceed2d6891721ffb47c7e2"><div class="ttname"><a href="namespacerotor.html#ae1d5cfad16ceed2d6891721ffb47c7e2">rotor::intrusive_ptr_t</a></div><div class="ttdeci">boost::intrusive_ptr&lt; T &gt; intrusive_ptr_t</div><div class="ttdoc">alias for intrusive pointer</div><div class="ttdef"><b>Definition:</b> arc.hpp:26</div></div>
<div class="ttc" id="astructrotor_1_1actor__base__t_html_af559ff2601f0b0d4ed2f678c9cf701d1"><div class="ttname"><a href="structrotor_1_1actor__base__t.html#af559ff2601f0b0d4ed2f678c9cf701d1">rotor::actor_base_t::shutdown_start</a></div><div class="ttdeci">virtual void shutdown_start() noexcept</div><div class="ttdoc">starts shutdown procedure, e.g. upon receiving shutdown request</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
