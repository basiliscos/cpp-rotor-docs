<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rotor: Patterns</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="extra.css" rel="stylesheet" type="text/css" />
</head>
<body>
<a href="http://www.reactivemanifesto.org/"> <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000" src="//d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-white-right.png"> </a>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rotor
   </div>
   <div id="projectbrief">Event loop friendly C++ actor micro-framework</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_b_development_cpp_cpp-rotor_docs_Patterns.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Patterns </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Networking mindset hint: try to think of messages as if they where UDP-datagrams, supervisors as different network IP-addresses (which might or might not belong to the same host), and actors as an opened ports (or as endpoints, i.e. as IP-address:port).</p>
<h1>Multiple actor identities</h1>
<p>Every actor has it's "main" address; however it is possible for it to have multiple addresses. This makes it available to have "inside actor" routing, or polymorphism. This is useful when the <b>same type</b> of messages arrive in response to different queries.</p>
<p>For example, let's assume that there is an "http-actor", which is able to "execute" http requests in generic way and return back the replies. If there is a SOAP/WSDL -webservice, the first query will be "get list of serices", and the second query will be "execute an action X". The both responses will be HTTP-replies.</p>
<p>Something like the following can be done:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>client_t: <span class="keyword">public</span> r::actor_base_t {</div>
<div class="line">    r::address_ptr_t http_client;</div>
<div class="line">    r::address_ptr_t wsdl_addr;</div>
<div class="line">    r::address_ptr_t action_addr;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> configure(r::plugin::plugin_base_t &amp;plugin) noexcept <span class="keyword">override</span> {</div>
<div class="line">        ...</div>
<div class="line">        plugin.with_casted&lt;r::plugin::starter_plugin_t&gt;([&amp;](<span class="keyword">auto</span> &amp;p) {</div>
<div class="line">            wsdl_addr = create_address();</div>
<div class="line">            action_addr = create_address();</div>
<div class="line">            p.subscribe_actor(&amp;client_t::on_wsdl, wsdl_addr);</div>
<div class="line">            p.subscribe_actor(&amp;client_t::on_action, action_add);</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> on_wsdl(http_message_t&amp; msg) noexcept {</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> on_action(http_message_t&amp; msg) noexcept {</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> on_a_start() noexcept<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keyword">auto</span> timeout = r::pt::seconds(1);</div>
<div class="line">        request_via&lt;htt::request_t&gt;(http_client, wsdl_addr, <span class="comment">/* request params */</span> ).send(timeout);</div>
<div class="line">        request_via&lt;htt::request_t&gt;(http_client, action_addr, <span class="comment">/* request params */</span> ).send(timeout);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1>Request/Responce</h1>
<p>While <a href="https://en.wikipedia.org/wiki/Request%E2%80%93response">request-response</a> approach is widely know, it has it's own specific on the actor-model:</p>
<ol type="1">
<li>the response (message) arrives asynchronously and there is need to match the original request (message)</li>
<li>the response might not arrive at all (e.g. an actor is down)</li>
</ol>
<p>The first issue is solved in rotor via including full original message (intrusive pointer) into response (message). This also means, that the receiver (the "server") replies not to the message with the original user-defined payload, but slightly enreached one; the same relates to the response (the "client" side).</p>
<p>The second issues is solved via spawning a <em>timer</em>. Obviously, that the timer should be spawned on the client-side. In the case of timeout, the client-side should receive the response message with the timeout error (and if the response arrives in a moment later it should be discarded). All the underhood mechanics is performed by supervisor, and there is a need of generic request/response matching, which can be done by introducing some synthetic message id per request. Hence, the response can't be just original user-defined payload, it's needed to be enriched a little bit to.</p>
<p>A little bit more of terminology: the regular messages, which are not request nor response might have different names to emphasize their role: signals, notifications, or triggers.</p>
<p><code>rotor</code> provides support for the <a href="https://en.wikipedia.org/wiki/Request%E2%80%93response">request-response</a> pattern.</p>
<p>First, you need to define your payloads in the request and response messages, linking the both types</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>payload {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>my_response_t {</div>
<div class="line">    <span class="comment">// my data fields</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>my_request_t {</div>
<div class="line">    <span class="keyword">using</span> response_t = my_response_t;</div>
<div class="line">    <span class="comment">// my data fields</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><p>Second, you need to wrap them to let <code>rotor</code> knows that this is request/response pair:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>message {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> request_t = r::request_traits_t&lt;payload::my_request_t&gt;::request::message_t;</div>
<div class="line"><span class="keyword">using</span> response_t = r::request_traits_t&lt;payload::my_request_t&gt;::response::message_t;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Third, on the client side, the <code>request</code> method should be used (or <code>request_via</code> if the answer is expected on the non-default address) and a bit specific access to the user defined payload should be used, i.e.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>client_actor_t : <span class="keyword">public</span> r::actor_base_t {</div>
<div class="line">    r::address_ptr_t server_addr;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> configure(r::plugin::plugin_base_t &amp;plugin) noexcept <span class="keyword">override</span> {</div>
<div class="line">        r::actor_base_t::configure(plugin);</div>
<div class="line">        plugin.with_casted&lt;r::plugin::starter_plugin_t&gt;(</div>
<div class="line">            [](<span class="keyword">auto</span> &amp;p) { p.subscribe_actor(&amp;client_actor::on_response); });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> on_start() noexcept<span class="keyword"> override </span>{</div>
<div class="line">        r::actor_base_t::on_start();</div>
<div class="line">        <span class="keyword">auto</span> timeout = r::pt::milliseconds{10};</div>
<div class="line">        request&lt;payload::sample_req_t&gt;(server_addr, <span class="comment">/* fields-forwaded-for-request-payload */</span>)</div>
<div class="line">            .send(timeout);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> on_response(message::response_t&amp; msg) noexcept <span class="keyword">override</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (msg.payload.ec) {</div>
<div class="line">            <span class="comment">// react somehow to the error, i.e. timeout</span></div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">auto</span>&amp; req = msg.payload.req-&gt;payload; <span class="comment">// original request payload</span></div>
<div class="line">        <span class="keyword">auto</span>&amp; res = msg.payload.res;          <span class="comment">// original response payload</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Forth, on the server side the <code>reply_to</code> or <code>reply_with_error</code> methods should be used, i.e.:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>server_actor_t : <span class="keyword">public</span> r::actor_base_t {</div>
<div class="line">    r::address_ptr_t server_addr;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> configure(r::plugin::plugin_base_t &amp;plugin) noexcept <span class="keyword">override</span> {</div>
<div class="line">        r::actor_base_t::configure(plugin);</div>
<div class="line">        plugin.with_casted&lt;r::plugin::starter_plugin_t&gt;(</div>
<div class="line">            [](<span class="keyword">auto</span> &amp;p) { p.subscribe_actor(&amp;server_actor::on_request); });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> on_request(message::request_t&amp; msg) noexcept <span class="keyword">override</span> {</div>
<div class="line">        <span class="keyword">auto</span>&amp; req = msg.payload.request_payload; <span class="comment">// original request payload</span></div>
<div class="line">        <span class="keywordflow">if</span> (some_condition) {</div>
<div class="line">            reply_to(msg, <span class="comment">/*, fields-forwaded-for-response-payload */</span>);</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        std::eror_code ec = <span class="comment">/* .. make somehow app-specific error code */</span>;</div>
<div class="line">        reply_with_error(msg, ec);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, the story does not end here. As you might already guess, the response message arrives to the client supervisor first, where it might be discarded (if timeout timer already triggered), or it might be delivered further to the client. As the <code>rotor</code> library should not modify the user-defined message at will, the new response message is created <em>via copying</em> the original one. As this might be not desirable, rotor is able to handle that: instead of copying the content, the intrusive pointer to it can be created, i.e.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>payload {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>my_response_t:  r::arc_base_t&lt;my_response_t&gt;  {  <span class="comment">// intrusive pointer support</span></div>
<div class="line">    <span class="comment">// my data fields</span></div>
<div class="line">    <span class="keyword">explicit</span> my_response_t(<span class="keywordtype">int</span> value_) { ... } <span class="comment">// the constructor must be provided</span></div>
<div class="line">    <span class="keyword">virtual</span> ~my_response_t() {}                <span class="comment">// the virtual destructor must be provided</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>my_request_t {</div>
<div class="line">    <span class="keyword">using</span> response_t = r::intrusive_ptr_t&lt;my_response_t&gt;;   <span class="comment">// that&#39;s also changed</span></div>
<div class="line">    <span class="comment">// my data fields</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><p>That's way responses, with heavy to- copy payload might be created. See <code>examples/boost-asio/request-response.cpp</code> as the example.</p>
<h1>Registry</h1>
<p>There is a known <a href="https://en.wikipedia.org/wiki/Actor_model#Synthesizing_addresses_of_actors">get-actor-address</a> problem: how one actor should know the address of the other actor? Well known way is to carefully craft initialization taking addresses of just created actors and pass them in constructor to the other actors etc. The approach will work in the certain circumstances; however it leads to boilerplate and fragile code, which "smells bad", as some initialization is performed inside actors and some is outside; it also does not handle well the case of dynamic (virtual) addresses.</p>
<p>The better solution is to have "the registry" actor, known to all other actors. Each actor, which provides some services registers it's main or virtual address in the registry via some application-known string names; upon the termination it undoes the registration. Each "client-actor" asks for the predefined service point by it's name in the actor initialization phase; once all addresses for the needed services are found, the initialization can continue and the actor then becomes "operational".</p>
<p>Since the registry does not perform any I/O and can be implemented in loop-agnostic way, it was included in <code>rotor</code> since <code>v0.06</code>, however the most convenient usage comes with <code>v0.09</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>server_actor : <span class="keyword">public</span> <a class="code" href="structrotor_1_1actor__base__t.html">rotor::actor_base_t</a> {</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="structrotor_1_1actor__base__t.html#a1c7143d733572600a355d8bcb02367bc">configure</a>(<a class="code" href="structrotor_1_1plugin_1_1plugin__base__t.html">rotor::plugin::plugin_base_t</a> &amp;plugin) noexcept <span class="keyword">override</span> {</div>
<div class="line">        ...</div>
<div class="line">        plugin.with_casted&lt;<a class="code" href="structrotor_1_1plugin_1_1registry__plugin__t.html">rotor::plugin::registry_plugin_t</a>&gt;(</div>
<div class="line">            [&amp;](<span class="keyword">auto</span> &amp;p) { p.register_name(<span class="stringliteral">&quot;server&quot;</span>, <a class="code" href="structrotor_1_1actor__base__t.html#a3b9c6102ea139c35745d47927ce4d613">get_address</a>()); });</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>client_actor : <span class="keyword">public</span> <a class="code" href="structrotor_1_1actor__base__t.html">rotor::actor_base_t</a> {</div>
<div class="line">    <a class="code" href="namespacerotor.html#a25565725c774761a67bd766d93617326">rotor::address_ptr_t</a> server_addr;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="structrotor_1_1actor__base__t.html#a1c7143d733572600a355d8bcb02367bc">configure</a>(<a class="code" href="structrotor_1_1plugin_1_1plugin__base__t.html">rotor::plugin::plugin_base_t</a> &amp;plugin) noexcept <span class="keyword">override</span> {</div>
<div class="line">        ...</div>
<div class="line">        plugin.with_casted&lt;<a class="code" href="structrotor_1_1plugin_1_1registry__plugin__t.html">rotor::plugin::registry_plugin_t</a>&gt;(</div>
<div class="line">            [&amp;](<span class="keyword">auto</span> &amp;p) { p.discover_name(<span class="stringliteral">&quot;server&quot;</span>, server_addr, <span class="keyword">true</span>).link(); });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">auto sup = system_context-&gt;create_supervisor&lt;...&gt;()</div>
<div class="line">           ...</div>
<div class="line">           .create_registry()</div>
<div class="line">           .finish();</div>
</div><!-- fragment --><p>Please note, to let the things work, the <code>registry</code> actor is created by supervisor, so all other child actors ("server" and "client") know the mediator.</p>
<p>During initialization phase the client actor discovers server address into the <code>server_addr</code> variable, and when done, it links to it. If something goes wrong it will shutdown, otherwise it will become operational. Additional synchronization patterns are used here.</p>
<h1>Synchronization patterns</h1>
<h2>Delayed discovery</h2>
<p>There is a race condition in the registry example: the server-actor might register self in the registry a little bit later than a client-actor asks for server-actor address. The registry will reply to the client-actor with error, which will cause client-actor to shutdown down.</p>
<div class="fragment"><div class="line">p.discover_name(<span class="stringliteral">&quot;server&quot;</span>, server_addr, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>The <code>true</code> parameter here asks the registry not to fail, but reply to the client-actor as soon as server actor will register self.</p>
<p>What will happen, if the server-actor will never register self in the registry? Than in the client-actor discovery timeout will trigger and the client-actor will shutdown.</p>
<h2>Linking actors</h2>
<p>When two actors performing an interaction via messages they need to stay <b>operational</b>, but they are some kind autonomous entities and can shut self down at any time. How to deal with that? The actor linking mechanism was invented: when a client-actor is linked to server-actor, and server actor is going to shutdown then it will ask the client-actor to unlink. That way the client actor will shutdown too, but it still have time to perform emergency cleaning (e.g. flush caches). Then a supervisor might restart client and server actors, according to its policy. The API looks like:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>client_actor : <span class="keyword">public</span> <a class="code" href="structrotor_1_1actor__base__t.html">rotor::actor_base_t</a> {</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="structrotor_1_1actor__base__t.html#a1c7143d733572600a355d8bcb02367bc">configure</a>(<a class="code" href="structrotor_1_1plugin_1_1plugin__base__t.html">rotor::plugin::plugin_base_t</a> &amp;plugin) noexcept <span class="keyword">override</span> {</div>
<div class="line">        ...</div>
<div class="line">        plugin.with_casted&lt;<a class="code" href="structrotor_1_1plugin_1_1registry__plugin__t.html">rotor::plugin::registry_plugin_t</a>&gt;(</div>
<div class="line">            [&amp;](<span class="keyword">auto</span> &amp;p) { p.discover_name(<span class="stringliteral">&quot;server&quot;</span>, server_addr, <span class="keyword">true</span>).link(<span class="keyword">false</span>); }); <span class="comment">// (1)</span></div>
<div class="line"> </div>
<div class="line">        plugin.<a class="code" href="structrotor_1_1plugin_1_1plugin__base__t.html#acf872f647caddf6a865e22f629964532">with_casted</a>&lt;r::plugin::link_client_plugin_t&gt;([&amp;](<span class="keyword">auto</span> &amp;p) {</div>
<div class="line">            p.link(addr_s, <span class="keyword">false</span>, callback);                                            <span class="comment">// (2)</span></div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>(1)</code> is convenient api to link after discovery, which the most likely you should use as it covers most use cases. The <code>(2)</code> is more low-level API, where it is possible to setup callback (it is available in <code>(1)</code> too), and the target actor address have to be specified.</p>
<p>The special <code>bool</code> argument available in the both versions make postponed link confirmation, i.e. only upon server-actor start. Usually, this is have to be <code>false</code>.</p>
<p>It should be noted, that it is possible to make a cycle of linked actors. While this will work, it will never shutdown properly. So, it is better to avoid cycles.</p>
<h2>Synchronized start</h2>
<p>By default actor is started as soon as possible, i.e. once it confirmed initialization its supervisor sends it start trigger. However, this behavior is not always desirable, and there is need of barrier-like action, i.e. to let all child actors on a supervisor start simultaneously. The special option <code>synchronized_start</code> is response for that:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sup = system_context.create_supervisor&lt;<a class="code" href="structrotor_1_1ev_1_1supervisor__ev__t.html">rotor::ev::supervisor_ev_t</a>&gt;()</div>
<div class="line">               .synchronize_start()</div>
<div class="line">               .timeout(...)</div>
<div class="line">               .finish();</div>
</div><!-- fragment --><h2>Blocking I/O multiplexing</h2>
<p>This is mostly related to <code>thread</code> backend. When there is a need to perform long/blocking /synchronous work, like disk I/O or interraction with database, or matrices computation etc., still there is need of <b>being reactive</b>, i.e. actor should respond on other messages or timers should fire.</p>
<p>Implementing blocking I/O naively, i.e. doing all work at once will make an actor (and the entire thread) unresponsible. So, the solution is the following: break the whole job into smaller pieces (read from disk a by a few megabytes chunks, read/write a thousands of rows into DB or multiply a few colums/rows in matrices) and pack whole job into a message. Then, send a message to an actor. The actor will process the message, and if the job has yet not being complete, send it as a message to self again, asking to process the next chunk etc. Other messages will be processed between work-messages.</p>
<p>To let it work, the blocking I/O message handler, should be tagged specially, i.e.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> configure(r::plugin::plugin_base_t &amp;plugin) noexcept <span class="keyword">override</span> {</div>
<div class="line">    ...</div>
<div class="line">    plugin.with_casted&lt;r::plugin::starter_plugin_t&gt;([&amp;](<span class="keyword">auto</span> &amp;p) {</div>
<div class="line">        p.subscribe_actor(&amp;my_actor::on_my_work_message)-&gt;tag_io(); <span class="comment">// important</span></div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><p>There is an example demostrating the technique, see <code>examples/thread/sha512.cpp</code>.</p>
<h1>Multiple Producers Multiple Consumers (MPMC aka pub-sub)</h1>
<p>A <code>message</code> is delivered to <code>address</code>, independently of subscriber or subscribers, i.e. to one <code>address</code> there can subscribed many actors, as well as messages can be send from multiple sources to the same <code>address</code>.</p>
<p>It should be noted, that an <b>message delivery order is source-actor sequenced</b>, so it is wrong assumption that the same message will be delivered simultaneously to different subscribers (actors), if they belong to different supervisors/threads. Never assume that, nor assume that the message will be delivered with some guaranteed timeframe.</p>
<p>Technically in <code>rotor</code> it is implemented the following way: <code>address</code> is produced by some <code>supervisor</code>. The sent to an address message is processed by the supervisor: if the actor-subscriber is <em>local</em> (i.e. created on the <code>supervisor</code>), then the message is delivered immediately to it, otherwise the message is wrapped and forwarded to the supervisor of the actor (i.e. to some <em>foreign</em> supervisor), and then it is unwrapped and delivered to the actor.</p>
<h1>Observer (mirroring traffic)</h1>
<p>Each <code>actor</code> has it's own <code>address</code>. Due to MPMC-feature above it is possible that first actor will receive messages for processing, and some other actor ( <em>foreign</em> actor) is able to subscribe to the same kind of messages and observe them (with some latency). It is possible observe even <code>rotor</code> "internal" messages, however it is discouraged since there are more reliable synchronization approaches.</p>
<p>Let's assume that server-actor via non-rotor I/O somehow generates data (e.g. it measures temperature once per second). Where should it send it if the consumers of the data are dynamic (e.g. connected from network)? The solution is to send metrics to itself, while dynamical clients should discover and link to the sensor actor, and then subscribe to metrics on the sensor actor address.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>r = <a class="code" href="namespacerotor.html">rotor</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>payload {</div>
<div class="line">    <span class="keyword">struct </span>temperature_t { <span class="keywordtype">double</span> value; };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message {</div>
<div class="line">    <span class="keyword">using</span> temperature_notification_t = message_t&lt;payload::temperature_t&gt;;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>sensor_actor_t: <span class="keyword">public</span> r::actor_base_t {</div>
<div class="line">    <span class="comment">// registration &quot;service::sensor&quot; is omitted</span></div>
<div class="line">    <span class="keywordtype">void</span> on_new_temperature(<span class="keywordtype">double</span> value) {</div>
<div class="line">        <span class="comment">// yep, send it to itself</span></div>
<div class="line">        send&lt;payload::temperature_t&gt;(address, value);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>client_actor_t: <span class="keyword">public</span> r::actor_base_t {</div>
<div class="line">    r::address_ptr_t sensor_addr;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> configure(r::plugin::plugin_base_t &amp;plugin) noexcept <span class="keyword">override</span> {</div>
<div class="line">        r::actor_base_t::configure(plugin);</div>
<div class="line">        plugin.with_casted&lt;r::plugin::registry_plugin_t&gt;([&amp;](<span class="keyword">auto</span> &amp;p) {</div>
<div class="line">            p.discover_name(<span class="stringliteral">&quot;service::sensor&quot;</span>, sensor_addr)</div>
<div class="line">                .link()</div>
<div class="line">                .callback([&amp;](<span class="keyword">auto</span> phase, <span class="keyword">auto</span> &amp;ec) <span class="keyword">mutable</span> {</div>
<div class="line">                    <span class="keywordflow">if</span> (phase == r::plugin::registry_plugin_t::phase_t::linking &amp;&amp; !ec) {</div>
<div class="line">                        <span class="keyword">auto</span> subscriber = get_plugin(r::plugin::starter_plugin_t::class_identity);</div>
<div class="line">                        <span class="keyword">static_cast&lt;</span>r::plugin::starter_plugin_t*<span class="keyword">&gt;</span>(subscriber)-&gt;subscribe_actor(&amp;client_actor_t::on_temperature);</div>
<div class="line">                    }</div>
<div class="line">                });</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> on_temperature(message::temperature_notification_t&amp; msg) noexcept {</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>That way it is possible to "spy" messages of the sensor actor. To avoid synchronization issues the client should discover and link to the sensor actor.</p>
<p>The distinguish of <em>foreign and non-foreign</em> actors or MPMC pattern is completely <b>architectural</b> and application specific, i.e. whether it is known apriori that there are multiple subscribers (MPMC) or single subscriber and other subscribes are are hidden from the original message flow. There is no difference between them at the <code>rotor</code> core, i.e.</p>
<div class="fragment"><div class="line"><span class="comment">// MPMC: an address is shared between actors</span></div>
<div class="line"><span class="keyword">auto</span> dest1 = supervisor-&gt;make_address();</div>
<div class="line"><span class="keyword">auto</span> actor_a = sup-&gt;create_actor&lt;...&gt;();</div>
<div class="line"><span class="keyword">auto</span> actor_b = sup-&gt;create_actor&lt;...&gt;();</div>
<div class="line">actor_a-&gt;set_destination(dest1);</div>
<div class="line">actor_b-&gt;set_destination(dest1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// observer: actor_c own address is exposed for actor_d</span></div>
<div class="line"><span class="keyword">auto</span> actor_c = sup-&gt;create_actor&lt;...&gt;();</div>
<div class="line"><span class="keyword">auto</span> actor_d = sup-&gt;create_actor&lt;...&gt;();</div>
<div class="line">actor_d-&gt;set_c_addr(actor_c-&gt;get_address());</div>
</div><!-- fragment --><p>Of course, actors can dynamically subscribe/unsubscribe from address at runtime.</p>
<h1>Actor overload protection (workload balancing)</h1>
<p><a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> ships with build-in message box protection, i.e. when inbound message queue hits certain threshold an predefined action can be performed: an message can be silently dropped (the newest one), it can be transformed to some other kind of message, or actor or application can be shut down etc.</p>
<p>In <code>rotor</code> there is no "inbound" queue, and the <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a>'s approach is not flexible enough: the overloading not always measured in number of unprocessed messages, it can be measured in time for processing single message. For example, there is a queue of request to compute Nth-prime number. If the N lies within 1000, then queue size of 1000 messages is probably OK; however if there is an request to compute 10_000_000-th prime number an actor will certainly be overloaded.</p>
<p>There can be at least two approaches, depending how fast the reaction to overload should be triggered. In the simplest case, when there is no timeframe guarantee for overload reaction, it can be do as the following: an custom <code>supervisor</code> shoud be written, messages to protected supervisor should be delivered not immediately, but with some delay (i.e. <code>loop-&gt;postone([&amp;](supervisor-&gt;do_process())</code>) and before message delivery to the actor the queue size (or other criteria for overloading condition) should be checked, then overload-reaction should be performed.</p>
<p>Another approach will be write an front-actor, which will run on dedicated supervisor / thread. The actor will forward requests to protected worker-actor, if the worker-actor answers within certain timeframe, or immediately react with overload action. This will work, if the request-message, contains reply address, which will be remembered and overwritten by front-actor, before forwaring the message to worker-actor, and in the reply-message the address might be needed to be overwritten too. The strategy can be extended to use several workers, and, hence, provide application-specific load balancing.</p>
<h1>Real networking</h1>
<p>This is not yet started, however a lot of building blocks for networking are already here: the <b>location transparency</b>, message passing and reactiveness are here. The missing blocks are: handshake and message serialization, for which it is needed to have reflections in C++.</p>
<p>The final goal is: the <code>send&lt;payload&gt;(destination_address, args...)</code> should send the message to some <em>local</em> <code>destination_address</code>, which is the representative of some <em>remote</em> peer actor address, where the addresses will be NAT-ed and message will be serialized and transferred over the wire to remote host, where it (request) will be deserialized, processed and replied back and reverse procedure will happen.</p>
<p>Whilst the actual network transmission cannot implemented in a event loop agnostic way, <em>I think</em> the abovementioned protocol seems quite easy in a loop independent. This is the area of further <code>rotor</code> research &amp; development. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="astructrotor_1_1plugin_1_1registry__plugin__t_html"><div class="ttname"><a href="structrotor_1_1plugin_1_1registry__plugin__t.html">rotor::plugin::registry_plugin_t</a></div><div class="ttdoc">handy access to registry_t, for name registration and discovery</div><div class="ttdef"><b>Definition:</b> registry.h:29</div></div>
<div class="ttc" id="astructrotor_1_1ev_1_1supervisor__ev__t_html"><div class="ttname"><a href="structrotor_1_1ev_1_1supervisor__ev__t.html">rotor::ev::supervisor_ev_t</a></div><div class="ttdoc">delivers rotor-messages on top of libev event loop</div><div class="ttdef"><b>Definition:</b> supervisor_ev.h:35</div></div>
<div class="ttc" id="astructrotor_1_1plugin_1_1plugin__base__t_html"><div class="ttname"><a href="structrotor_1_1plugin_1_1plugin__base__t.html">rotor::plugin::plugin_base_t</a></div><div class="ttdoc">base class for all actor plugins</div><div class="ttdef"><b>Definition:</b> plugin_base.h:21</div></div>
<div class="ttc" id="astructrotor_1_1plugin_1_1plugin__base__t_html_acf872f647caddf6a865e22f629964532"><div class="ttname"><a href="structrotor_1_1plugin_1_1plugin__base__t.html#acf872f647caddf6a865e22f629964532">rotor::plugin::plugin_base_t::with_casted</a></div><div class="ttdeci">void with_casted(Fn &amp;&amp;fn, config_phase_t desired_phase=config_phase_t::INITIALIZING) noexcept</div><div class="ttdoc">invokes the callback if plugin type and phase mach</div><div class="ttdef"><b>Definition:</b> plugin_base.h:137</div></div>
<div class="ttc" id="astructrotor_1_1actor__base__t_html_a1c7143d733572600a355d8bcb02367bc"><div class="ttname"><a href="structrotor_1_1actor__base__t.html#a1c7143d733572600a355d8bcb02367bc">rotor::actor_base_t::configure</a></div><div class="ttdeci">virtual void configure(plugin::plugin_base_t &amp;plugin) noexcept</div><div class="ttdoc">main callback for plugin configuration when it's ready</div></div>
<div class="ttc" id="astructrotor_1_1actor__base__t_html_a3b9c6102ea139c35745d47927ce4d613"><div class="ttname"><a href="structrotor_1_1actor__base__t.html#a3b9c6102ea139c35745d47927ce4d613">rotor::actor_base_t::get_address</a></div><div class="ttdeci">const address_ptr_t &amp; get_address() const noexcept</div><div class="ttdoc">returns actor's main address</div><div class="ttdef"><b>Definition:</b> actor_base.h:280</div></div>
<div class="ttc" id="anamespacerotor_html_a25565725c774761a67bd766d93617326"><div class="ttname"><a href="namespacerotor.html#a25565725c774761a67bd766d93617326">rotor::address_ptr_t</a></div><div class="ttdeci">intrusive_ptr_t&lt; address_t &gt; address_ptr_t</div><div class="ttdoc">intrusive pointer for address</div><div class="ttdef"><b>Definition:</b> address.hpp:59</div></div>
<div class="ttc" id="astructrotor_1_1actor__base__t_html"><div class="ttname"><a href="structrotor_1_1actor__base__t.html">rotor::actor_base_t</a></div><div class="ttdoc">universal primitive of concurrent computation</div><div class="ttdef"><b>Definition:</b> actor_base.h:41</div></div>
<div class="ttc" id="anamespacerotor_html"><div class="ttname"><a href="namespacerotor.html">rotor</a></div><div class="ttdoc">Basic namespace for all rotor functionalities.</div><div class="ttdef"><b>Definition:</b> actor_base.h:18</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
