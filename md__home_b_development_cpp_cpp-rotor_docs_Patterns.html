<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rotor: Patterns</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rotor
   </div>
   <div id="projectbrief">Event loop friendly C++ actor micro-framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_b_development_cpp_cpp-rotor_docs_Patterns.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Patterns </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Networking mindset hint: try to think of messages as if they where UDP-datagrams, supervisors as different network IP-addresses (which might or might not belong to the same host), and actors as an opened ports (or as endpoints, i.e. as IP-address:port).</p>
<h2>Multiple Producers Multiple Consumers (MPMC aka pub-sub)</h2>
<p>An <code>message</code> is delivered to <code>address</code>, independently subscriber or subscribers, i.e. to one <code>address</code> there can subscribed many actors, as well as messages can be send from multiple sources to the same <code>address</code>.</p>
<p>It should be noted, that an <b>message delivery order is source-actor sequenced</b>, so it is wrong assumption that the same message will be delivered simultaneously to different subscribers (actors), if they belong to different supervisors/threads. Never assume that, nor assume that the message will be delivered with some guaranteed timeframe.</p>
<p>Technically in <code>rotor</code> it is implemented the following way: <code>address</code> is produced by some <code>supervisor</code>. The sent to the addres message it is processed by the supervisor: if the actor-subscriber is <em>local</em> (i.e. created on the <code>supervisor</code>), then the message is delivered immediately to it, othewise the message is wrapped and forwarded to the supervisor of the actor (i.e. to some <em>foreign</em> supervisor), and then it is unwrapped and delivered to the actor.</p>
<h2>Observer (mirroring traffic)</h2>
<p>Each <code>actor</code> has it's own <code>address</code>. Due to MPMC-feature above it is possible that first actor will receive messages for processing, and some other actor ( <em>foreign</em> actor) is able to subscribe to the same kind of messages and observe them (with some latency). It is possible observe even <code>rotor</code> "internal" messages, which are part of the API. In other words it is possible to do something like:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>r = rotor;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>observer_t: <span class="keyword">public</span> r::actor_base_t {</div><div class="line">    r::address_ptr_t observable;</div><div class="line">    <span class="keywordtype">void</span> set_observable(r::address_ptr_t addr) { observable = std::move(addr); }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> on_initialize(r::message_t&lt;r::payload::initialize_actor_t&gt; &amp;msg) noexcept <span class="keyword">override</span> {</div><div class="line">        r::actor_base_t::on_initialize(msg);</div><div class="line">        subscribe(&amp;observer_t::on_target_initialize, observable);</div><div class="line">        subscribe(&amp;observer_t::on_target_start, observable);</div><div class="line">        subscribe(&amp;observer_t::on_target_shutdown, observable);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> on_target_initialize(r::message_t&lt;r::payload::initialize_actor_t&gt; &amp;msg) noexcept {</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> on_target_start(r::message_t&lt;r::payload::start_actor_t&gt; &amp;) noexcept {</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> on_target_shutdown(r::message_t&lt;r::payload::shutdown_request_t&gt; &amp;) noexcept {</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    ...</div><div class="line">    <span class="keyword">auto</span> observer = sup-&gt;create_actor&lt;observer_t&gt;();</div><div class="line">    <span class="keyword">auto</span> target_actor = sup-&gt;create_actor&lt;...&gt;();</div><div class="line">    observer-&gt;set_observable(sample_actor-&gt;get_address());</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>It should noted, that subscription request is regular <code>rotor</code> message, i.e. sequence of arrival of messages is undefined as soon as they are generated in different places; hence, an observer might be subscired <em>too late</em>, while the original messages has already been delivered to original recipient and the observer "misses" the message. See the pattern below how to synronize actors.</p>
<p>The distinguish of <em>foreign and non-foreign</em> actors or MPMC pattern is completely <b>architectural</b> and application specific, i.e. whether is is known apriori that there are multiple subscribers (MPMC) or single subsciber and other subscribes are are hidden from the original message flow. There is no difference between them at the <code>rotor</code> core, i.e.</p>
<div class="fragment"><div class="line"><span class="comment">// MPMC</span></div><div class="line"><span class="keyword">auto</span> dest1 = supervisor-&gt;make_address();</div><div class="line"><span class="keyword">auto</span> actor_a = sup-&gt;create_actor&lt;...&gt;();</div><div class="line"><span class="keyword">auto</span> actor_b = sup-&gt;create_actor&lt;...&gt;();</div><div class="line">actor_a-&gt;set_destination(dest1);</div><div class="line">actor_b-&gt;set_destination(dest1);</div><div class="line"></div><div class="line"><span class="comment">// observer</span></div><div class="line"><span class="keyword">auto</span> actor_c = sup-&gt;create_actor&lt;...&gt;();</div><div class="line"><span class="keyword">auto</span> actor_d = sup-&gt;create_actor&lt;...&gt;();</div><div class="line">actor_d-&gt;set_c_addr(actor_c-&gt;get_address());</div></div><!-- fragment --><p>Of course, actors can dynamically subscribe/unsubscribe from address at runtime</p>
<h2>check actor ready state (syncrhonizing stream)</h2>
<p>Let's assume there are two actors, which need to communicate:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>r = rotor;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>payload{};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>actor_A_t: <span class="keyword">public</span> r::actor_base_t {</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> on_start(r::message_t&lt;r::payload::start_actor_t&gt; &amp;msg) noexcept <span class="keyword">override</span> {</div><div class="line">      r::actor_base_t::on_start(msg);</div><div class="line">      subscribe(&amp;actor_A_t::on_message);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> on_message(r::message_t&lt;payload&gt; &amp;msg) noexcept {</div><div class="line">    <span class="comment">//processing logic is here</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>actor_B_t : <span class="keyword">public</span> r::actor_base_t {</div><div class="line">  <span class="keywordtype">void</span> set_target_addr(<span class="keyword">const</span> r::address_ptr_t &amp;addr) { target_addr = addr; }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> on_start(r::message_t&lt;r::payload::start_actor_t&gt; &amp;msg) noexcept <span class="keyword">override</span> {</div><div class="line">      r::actor_base_t::on_start(msg);</div><div class="line">      send&lt;payload&gt;(target_addr);</div><div class="line">  }</div><div class="line"></div><div class="line">  r::address_ptr_t target_addr;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    ...;</div><div class="line">    <span class="keyword">auto</span> supervisor = ...;</div><div class="line">    <span class="keyword">auto</span> actor_a = supervisor-&gt;create_actor&lt;actor_A_t&gt;();</div><div class="line">    <span class="keyword">auto</span> actor_b = supervisor-&gt;create_actor&lt;actor_B_t&gt;();</div><div class="line"></div><div class="line">    actor_b-&gt;set_target_addr(actor_b-&gt;get_address());</div><div class="line">    supervisor-&gt;start();</div><div class="line">    ...;</div><div class="line">};</div></div><!-- fragment --><p>However here is a problem: the message delivery order is source-actor sequenced, it migth happen <code>actor_b</code> started be before <code>actor_a</code>, and the message with payload will be lost.</p>
<p>The following trick is possible:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>actor_A_t: <span class="keyword">public</span> r::actor_base_t {</div><div class="line">    <span class="comment">// instead of on_start</span></div><div class="line">    <span class="keywordtype">void</span> on_initialize(r::message_t&lt;r::payload::initialize_actor_t&gt; &amp;msg) noexcept <span class="keyword">override</span> {</div><div class="line">      r::actor_base_t::on_initialize(msg);</div><div class="line">      subscribe(&amp;actor_A_t::on_message);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>or even that way:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>actor_A_t: <span class="keyword">public</span> r::actor_base_t {</div><div class="line">    <span class="comment">// instead of on_start / on_initialize</span></div><div class="line">    <span class="keywordtype">void</span> do_initialize(r::system_context_t* ctx) noexcept <span class="keyword">override</span> {</div><div class="line">        r::actor_base_t::do_initialize(ctx);</div><div class="line">        subscribe(&amp;actor_A_t::on_message);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>That tricky way will definitely work under certain circumstances, i.e. when actors are created sequentially and they use the same supervisor etc.; however in generaral case there will be unavoidable race, and the approach will not work when different supervisors / event loops are used, or when some I/O is involved in the scheme (i.e. it needed to establish connection before subscription). This is not networking mindset neither.</p>
<p>The more robust approach is to start <code>actor_b</code> as usual, observe <code>on_start</code> event from <code>on_initialize</code> and poll the <code>actor_a</code> status. Then, <code>actor_b</code> will either first receive the <code>on_start</code> event from <code>actor_a</code>, which means that <code>actor_a</code> is ready, or it will receive <code>r::message_t&lt;r::payload::state_response_t&gt;</code> and further analysis should be checked (i.e. if status is <code>initialized</code> or <code>started</code> etc.).</p>
<p>Further, if it is desirable to scale this pattern, then <code>actor_b</code> should not even start unless <code>actor_a</code> is started, then <code>actor_b</code> should suspend it's <code>on_initialize</code> message. The following code demonstrates this approach:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>actor_A_t: <span class="keyword">public</span> r::actor_base_t {</div><div class="line">    <span class="comment">// we need to be ready to accept messages, when on_start message arrives</span></div><div class="line">    <span class="keywordtype">void</span> on_initialize(r::message_t&lt;r::payload::initialize_actor_t&gt; &amp;msg) noexcept <span class="keyword">override</span> {</div><div class="line">      r::actor_base_t::on_initialize(msg);</div><div class="line">      subscribe(&amp;actor_A_t::on_message);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>actor_B_t : <span class="keyword">public</span> r::actor_base_t {</div><div class="line">    r::message_t&lt;r::payload::initialize_actor_t&gt; init_message;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> on_initialize(r::message_t&lt;r::payload::initialize_actor_t&gt; &amp;msg) noexcept <span class="keyword">override</span> {</div><div class="line">        <span class="comment">// we are not finished initialization:</span></div><div class="line">        <span class="comment">// r::actor_base_t::on_initialize(msg);</span></div><div class="line">        init_message = msg;</div><div class="line">        subscribe(&amp;actor_B_t::on_a_state);</div><div class="line">        subscribe(&amp;actor_B_t::on_a_start, target_addr);</div><div class="line">        poll_a_state();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> poll_a_state() noexcept {</div><div class="line">        <span class="keyword">auto</span>&amp; sup_addr   = target_addr-&gt;supervisor.get_address();</div><div class="line">        <span class="keyword">auto</span> reply_addr  = get_address();</div><div class="line">        <span class="comment">// ask actor_a supervisor about actor_a state, and deliver reply back to me</span></div><div class="line">        send&lt;r::payload::state_request_t&gt;(sup_addr, reply_addr, target_addr);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> finish_init() noexcept {</div><div class="line">        r::actor_base_t::on_initialize(init_message);</div><div class="line">        init_message.reset();</div><div class="line">        unsubscribe(&amp;actor_B_t::on_a_state);                <span class="comment">// optional</span></div><div class="line">        unsubscribe(&amp;actor_B_t::on_a_start, target_addr);   <span class="comment">// optional</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> on_a_state(r::message_t&lt;r::payload::state_response_t&gt; &amp;msg) noexcept {</div><div class="line">        <span class="comment">// initialization is not finished</span></div><div class="line">        <span class="keywordflow">if</span> (init_message) {</div><div class="line">            <span class="keyword">auto</span>&amp; state = msg.payload.state;</div><div class="line">            <span class="keywordflow">if</span> (state == r::state_t::OPERATIONAL) {</div><div class="line">                finish_init();</div><div class="line">            } <span class="keywordflow">else</span> {</div><div class="line">                poll_a_state();</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> on_a_start(r::message_t&lt;r::payload::start_actor_t&gt; &amp;msg) noexcept <span class="keyword">override</span> {</div><div class="line">        <span class="keywordflow">if</span> (init_message) {</div><div class="line">            finish_init();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In real life, the things are a little bit more complex, however: <code>actor_a</code> might <em>never</em> start, or it might not start withing the certain timeframe, or actor_a's supervisor might not even reply. If nothing will be done, then <code>actor_b</code> will stuck in inifinte polling, consuming CPU resources. Do handle the cases, in <code>poll_a_state</code> method the timeout timer should be started and in <code>finish_init</code> it should be stopped; the re-poll should be performed not immediately, but again after some timeout. Plus, the <code>actor_b</code> should shutdown itself after certain number of attemps (or after some timeout). Within <code>rotor</code> all timers are event loop specific, and timeouts are application-specific, so, there is no generaral example, just an sketch of the idea.</p>
<h2>Actor overload protection (workload balancing)</h2>
<p><a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> ships with build-in message box protection, i.e. when inbound message queue hits certain threshold an predefined action can be performed: an message can be silently dropped (the newest one), it can be transformed to some other kind of message, or actor or application can be shutted down etc.</p>
<p>In <code>rotor</code> there is no "inbound" queue, and the <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a>'s approach is not flexible enough: the overloading not always measured in number of unprocessed messages, it can be measured in time for processing single message. For example, there is a queue of request to compute Nth-prime number. If the N lies within 1000, then queue size of 1000 messages is probably OK; however if there is an request to compute 10_000_000-th prime number an actor will certainly be overloaded.</p>
<p>There can be at least two approaches, depending how fast the reaction to overload should be triggered. In the simplest case, when there is no timeframe guarantee for overload reaction, it can be do as the following: an custom <code>supervisor</code> shoud be written, messages to protected supervisor should be delivered not immediately, but with some delay (i.e. <code>loop-&gt;postone([&amp;](supervisor-&gt;do_process())</code>) and before message delivery to the actor the queue size (or other criteria for overloading condition) should be checked, then overload-reaction should be performed.</p>
<p>Another approach will be write an front-actor, which will run on dedicated supervisor / thread. The actor will forward requests to protected worker-actor, if the worker-actor answers within certain timeframe, or immediately react with overload action. This will work, if the request-message, contains reply address, which will be remembered and overwritten by front-actor, before forwaring the message to worker-actor, and in the reply-message the address might be needed to be overwritten too. The strategy can be extended to use several workers, and, hence, provide application-specific load balancing.</p>
<h2>Real networking</h2>
<p>This is not yet started, however a lot of building blocks for networking are already here: the <b>location transparency</b>, message passing and reactiveness are here. The missing blocks are: service discovery, handshake, and message serialization.</p>
<p>The final goal is: the <code>send&lt;payload&gt;(destination_address, args...)</code> should send the message to some <em>local</em> <code>destination_address</code>, which is the representative of some <em>remote</em> peer actor address, where the addresses will be NAT-ed and message will be serialized and transferred over the wire to remote host, where it (request) will be deserialized, processed and replied back and reverse procedure will happen.</p>
<p>Whilst the actual network transmission cannot implemented in a event loop agnostic way, <em>I think</em> the abovementioned protocol seems quite an loop independent. This is the area of further <code>rotor</code> research &amp; development. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
