<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rotor: Design &amp; Notions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="extra.css" rel="stylesheet" type="text/css" />
</head>
<body>
<a href="http://www.reactivemanifesto.org/"> <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000" src="//d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-white-right.png"> </a>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rotor
   </div>
   <div id="projectbrief">Event loop friendly C++ actor micro-framework</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_b_development_cpp_cpp-rotor_docs_Design.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Design &amp; Notions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>address</b> is runtime entity, served as subscription and delivery point. Any <code>message</code> can be sent to an address; any <code>actor</code> can subscribe on any kind of messages on any address. An <code>address</code> is generated by <code>supervisor</code>, address holds reference to <code>supervisor</code>.</p>
<p><b>message</b> is runtime entity, which consists of destination <code>address</code> and user supplied mutable <code>payload</code>. Message are delivered to <code>actors</code>. <b>The order of delivery messages is source-actor sequenced</b>: if a source-<code>actor</code> generates messages <code>m1</code> and then <code>m2</code>, that is is guaranteed that <code>m1</code> will arrive to destination earlier then <code>m2</code>. Meanwhile there can be other messages <em>for the destination</em> from other senders. Sometimes, the approach is named <em>per-sender-FIFO</em>. The delivery itself to an actor is <em>not guaranteed</em>, not in the sense the <code>rotor</code> will loose it, but because the actor might be not yet ready for it (not subscribed), or the actor might be no longer ready for it (i.e. already unsubscribed). <code>payload</code> is <b>mutable</b>. It is user responsibility to allowed for an <code>actor</code> to change a payload in a thread-safe way, but it is recommended to do modifications only when it is known that an <code>actor</code> is single consumer of the message; if there are multiple consumers of the the messages it is recommended not to change the message, or provide synchronization mechanisms on the payload (discouraged, as locks/mutexes might lead to application deadlock).</p>
<p>The messaging in <code>rotor</code> resembles IP protocol: it is quite simple (compared to TCP), without delivery/strict delivery order guarantees, no streams, no timers etc., however solid foundation of distributed actors can be build on top of <code>rotor</code>, adding only <em>required guarantees</em>.</p>
<p><code>rotor</code> supports <a href="https://en.wikipedia.org/wiki/Reliability_(computer_networking)" title="reliable">reliable</a> messaging via adopting <a href="https://en.wikipedia.org/wiki/Request%E2%80%93response">request-response</a> pattern: whenver <code>request</code> message is sent timeout timer is spawn, if the <code>reply</code> isn't delivered in time, the sender is notified about the occurred error. If the reply is sent twice by mistake, the second reply message will be silently discarded.</p>
<p><b>actor</b> is runtime entity with user-defined reaction on incoming messages. An <code>actor</code> can send messages to other actors, as well as do interaction with with outer world (i.e. via loop, timers, I/O etc.). The main business-logic should be written in actors. An <code>actor</code> always is executed <em>in the context</em> of some <code>supervisor</code>.</p>
<p>Every <code>actor</code> has it's "main" address, used for rotor-internal messaging. In addition it can create as many as needed address ("identities"), which can be used for distinguishing <code>replies</code>.</p>
<p><b>supervisor</b> is special kind of <code>actor</code>, which encapsulates <em>infrastructure-logic</em>, i.e. responsible for spawning/terminating actors, interaction with loop (timeouts), and for message dispatching/delivering. All messages sent by spawned actors, are put into outbound queue of supervisor. <code>supervisor</code> was designed to represent <em>sequential execution context</em>, similar to <code>strand</code> from [boost-asio] (in fact has <code>strand</code> object for <code>rotor-boost</code>); in other words all messages are delivered sequentially within the context of an <code>supervisor</code>, and it is safe to call one some actor's method from some other actor, located on the same supervisor, if needed.</p>
<p><b>locality</b> is rotor-specific marker of <code>sequential execution context</code>. An supervisor might have an independent locality, i.e. execute only on its own (<code>strand</code>); or a list of supervisors might share the same <code>locality</code>. For some event loops (i.e. other then <a href="https://www.boost.org/doc/libs/release/libs/asio/" title="Boost Asio">boost-asio</a>), it it the only option. In other words it is "thread affinity" somewhat similar to <a href="https://en.wikipedia.org/wiki/Processor_affinity">cpu-affinity</a>.</p>
<p>Supervisors might form a tree-like structure making some kind of hierarchy of responsibilities. This allows to build a robust application via controlled degradation of its services when leaf-actors are restarted in case of error, then their supervisors (with all actors) are restarted and so on the error propagates until the root supervisor. The child restart policy is user-defined for each supervisor individually. For more details see the article <a href="https://basiliscos.github.io/blog/2019/08/19/cpp-supervisors/" title="Trees of Supervisors in C++">blog-cpp-supervisors</a>.</p>
<p><img src="supervising.png" alt="supervising" class="inline"/></p>
<p>For example, if actor <code>A3</code> is going down, the <code>supervisor_child</code> will receive a message about it, and it might decide either to spawn <code>A3</code> again, or if restart limit is reached, shutdown self and all other child actors <code>A1</code> and <code>A2</code>. The <code>supervisor_root</code> will receive down message of <code>supervisor_child</code>, and the decision to restart <code>supervisor_child</code> (with all it's children) or to shutdown self should be made again.</p>
<p>Unlike supervisors in <a href="https://en.wikipedia.org/wiki/Erlang_(programming_language)">Erlang</a>, the <a href="http://wiki.c2.com/?LetItCrash">let-it-crash</a> principle is not acceptable in C++, hence it is expected that actors will perform <code>shutdown</code> procedure. It is expected that an user will inherit <code>supervisor</code> class and write application specific reaction on an actor shutdown. For proper <code>supervisor</code> destruction, all externally held <code>addresses</code> should be destroyed.</p>
<p>It should be noted, that a "crash" is actually "controlled crash", i.e. ability of an actor to detect some non-fatal error state and notify about that to upstream supervisor. After that the supervisor <em>asks</em> for shutdown and the actor must <em>confirm</em> it (maybe after some delay, i.e. after asynchronous resources release). There is no magical remedy against abnormal failures, which lead to <code>std::abort</code> or <code>std::terminate</code>.</p>
<p>The <b>system_context</b> is runtime environment for supervisors, which holds <code>loop</code> or some other context, which should be accessible in thread-safe way. When an fatal error is encounted, it is delegated to <code>system_context</code>, which by default just prints it to <code>std::cerr</code> and invokes <code>std::abort()</code>.</p>
<p>All <code>rotor</code> entities above use <em>intrusive pointer</em> approach from <a href="https://www.boost.org/doc/libs/release/libs/smart_ptr/" title="Boost Smart Pointers">boost-smartptr</a>, with the thread-safe atomic counters by default. If it is known, that <code>rotor</code> actors will be used strictly on single thread, then it is possible to use faster non-atomic counters.</p>
<h1>Actor lifecycle</h1>
<p><img src="actor-lifecycle.png" alt="actor-lifecycle" class="inline"/></p>
<p>(yellow - actor state, purple - actor methods, green - behavior methods, light blue - call/messages from an actor to supervisor; yellow - actor state, orange - call/messages from supervisor to an actor).</p>
<p><b>Short story</b>: if you need customization, override <code>init_start()</code>, when your initialization (i.e. possible asynchronous resources acquisition) is finished call <code>init_start()</code>. For simple post-init (possibly synchronous) actions override <code>init_finish()</code>. Likewise, for suspending shutdown override <code>shutdown_start()</code> and call it later, once your resources will be (asynchronously) released. For simple post-shutdown (possibly synchronous) actions, override <code>shutdown_finish()</code></p>
<p><b>Long story</b>. An actor is constructed via a <code>supervisor</code> or in some thread-safe context (i.e. when <code>supervisor</code> is inactive). Then, within the same context the <code>do_initialize</code> method is invoked; it performs <em>early initialization</em>, i.e. subscription to rotor-message via the <code>supervisor</code>. The default behavior is created and plugged.</p>
<p>Then <code>supervisor</code> delivers a message for <code>on_initialize</code> method. By default <code>actor</code> calls records the init-message and calls <code>init_start</code>, which in its turn delegates initialization sequence to the behavior. The actor's behavior replies with confirmation to the init-message request and sets actor's state to <code>INITIALIZED</code>. Once the supervisor receives init-confirmation it sends <code>start_actor_t</code> messages, which, after receiving, advances actor's start to <code>OPERATIONAL</code>.</p>
<p>It is possible to "suspend" initialization by overriding <code>init_start()</code> method. For example it is possible to send messages to other actors, wait their replies, and if all is OK, continue/commit the initialization by calling <code>init_start()</code> of the base class. The <code>init_start()</code> method is good for asynchronous acquisition of resources, i.e. opening ports, connecting to other hosts etc.</p>
<p>Subscriptions to the additional local actor addresses can be performed here (if you need subscription confirmations before <code>on_start</code>, do subscribe <em>before</em> calling <code>init_start()</code>). If the actor subscribes to the external addresses, then, probably to avoid races, it should wait subscription confirmations and only then confirm initialization by calling <code>init_start()</code>.</p>
<p>Note, however, that init-message is a <b>request</b>, i.e. it is timeout-supervised; the default supervisor behavior will ask for shutdown the actor in the case of init timeout.</p>
<p>The <code>init_finish()</code> will be invoked as the last step of the initialization.</p>
<p>The shutdown procedure goes in similar way: after receiving shutdown-message, it is recorded and <code>shutdown_start()</code> is invoked. Override it to suspend (postpone) actor shutdown procedure, and call it once actor will be ready, i.e. additional messages can be send to other actors and their responses can be waited, and only then shutdown can be continued.</p>
<p>After starting shutdown procedure actor unsubscribes itself from all associated addresses, so most likely it will be not able to receive any other (user-defined) messages.</p>
<p>As with init, the shutdown message is a <b>request</b>, i.e. it is timeout-supervised; the default supervisor behavior will delegate the error to <code>system_context</code>, which by default will abort the application. If the reaction should be tuned, the custom supervisor behavior should be plugged.</p>
<p>After unsubscription from all addresses, the behavior sends shutdown-confirmation, sets the actors status to <code>SHUTTED_DOWN</code> and then <code>shutdown_finish()</code> is called.</p>
<p>In the <code>shutdown_finish()</code> is the final method called by <code>rotor</code>. For example, external addresses should be released to avoid memory leaks. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
