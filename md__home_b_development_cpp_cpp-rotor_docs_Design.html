<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rotor: Design &amp; Notions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rotor
   </div>
   <div id="projectbrief">Event loop friendly C++ actor micro-framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_b_development_cpp_cpp-rotor_docs_Design.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Design &amp; Notions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>address</code> is runtime entity, served as subscription and delivery point. Any <code>message</code> can be sent to an address; any <code>actor</code> can subscribe on any kind of messages on any address. An <code>address</code> is generated by <code>supervisor</code>, address holds strong reference to <code>supervisor</code>.</p>
<p><code>message</code> is runtime entity, which consists of destination <code>address</code> and user supplied mutable <code>payload</code>. Message are delivered to <code>actors</code>. <b>The order of delivery messages is source-actor sequenced</b>: if a source-<code>actor</code> generates messages <code>m1</code> and then <code>m2</code>, that is is guaranteed that <code>m1</code> will arrive to destination earlier then <code>m2</code>. Meanwhile there can be other messages <em>for the destination</em> from other senders. Sometimes, the approach is named <em>per-sender-FIFO</em>. The delivery itself to an actor is <em>not guaranteed</em>, not in the sense the <code>rotor</code> will loose it, but because the actor migth be not yet ready for it (not subscribed), or the actor migth be no longer ready for it (i.e. already unsubscribed). <code>payload</code> is <b>mutable</b>. It is user responsibility to allowed for an <code>actor</code> to change a payload in a thread-safe way, but it is recommended to do modifications only when it is known that an <code>actor</code> is single consumer of the message; if there are multiple consumers of the the messages it is recommended not to change the message, or provide synchronization mechanisms on the payload (discouraged, as locks/mutexes might lead to application deadlock).</p>
<p>The messaging in <code>rotor</code> resembles IP protocol: it is quite simple (compared to TCP), without delivery/strict delivery order guarantees, no streams, no timers etc., however solid foundation of distributed actors can be build on top of <code>rotor</code>, adding only <em>required guarantees</em>.</p>
<p><code>actor</code> is runtime entity, with user-defined reaction on incoming messages. An <code>actor</code> can send messages to other actors, as well as do interaction with with outer world (i.e. via loop, timers, I/O etc.). The main business-logic should be written in actors. An <code>actor</code> always is executed <em>in the constext</em> of some <code>supervisor</code>.</p>
<p><code>supervisor</code> is special kind of <code>actor</code>, which encapsulates <em>infrastructure-logic</em>, i.e. responsible for spawning/terminating actors, interaction with loop (timeouts), and for message dispatching/delivering. All messages sent by spawned actors, are put into outbound queue of supervisor. <code>supervisor</code> was designed to represent sequential execution context, similar to <code>strand</code> from [boost-asio] (in fact has <code>starnd</code> object for <code>rotor-boost</code>); in other words all messages are devivered sequentially within the context of an <code>supervisor</code>, and it is safe to call one some actor's method from some other actor, located on the same supervisor, if needed.</p>
<p>Unlike supervisors in <a href="https://en.wikipedia.org/wiki/Erlang_(programming_language)">Erlang</a>, the <a href="http://wiki.c2.com/?LetItCrash">let-it-crash</a> principle is not acceptable in C++, hence it is expected that actors will perform <code>shutdown</code> procedure. It is expected that an user will inherit <code>supervisor</code> class and write application specific reaction on an actor shutdown. For proper <code>supervisor</code> destruction, all extenrally held <code>addresses</code> should be destroyed.</p>
<p>The <code>system_context</code> is runtime environmen for supervisors, which holds <code>loop</code> or some other context, which should be accessible in thread-safe way. When an fatal error is encounted, it is delegated to <code>system_context</code>, which by default just prints it to <code>std::cerr</code> and invokes <code>std::abort()</code>.</p>
<p>All <code>rotor</code> entities above use <em>intrusive pointer</em> approach from <a href="https://www.boost.org/doc/libs/release/libs/smart_ptr/" title="Boost Smart Pointers">boost-smartptr</a>, with the thread-safe atomic counters by default. If it is known, that <code>rotor</code> actors will be used strictly on single thread, then it is possible to use faster non-atomic counters.</p>
<h2>Actor states</h2>
<img src="actor-states.png" alt="actor-states" class="inline"/>
<p>(blue - call/messages from an actor to supervisor; yellow - actor state, orange - call/messages from supervisor to an actor).</p>
<p>An actor is constructed via a <code>supervisor</code> or in some thread-safe context (i.e. when <code>supervisor</code> is inactive). Then, within the same context the <code>do_initialize</code> method is invoked; it performs <em>early initialization</em>, i.e. subscription to rotor-message via the <code>supervisor</code>.</p>
<p>Then <code>supervisor</code> delivers a message for <code>on_initialize</code> method. By default <code>actor</code> immediately replies to it with <code>initialize_confirmation</code> message and moving it's state to <code>INITIALIZED</code>. Then <code>supervisor</code> delivers a message for <code>on_start</code> method, moving actor's start to <code>OPERATIONAL</code>.</p>
<p>The derived class from <code>actor</code> is capable to suspend, for example, <code>intialization</code> message; that will trigger suspension of the <code>start</code> message send by supervisor. This is useful, when some other <code>actor</code> observes initialization of the current actor, i.e. the initialization of 2nd actor depends on the initialization of the 1st actor, so it is possible to have some kind of initialization chains. The "suspension" of message is done via holding <code>initialization</code> message and NOT invoking the <code>on_initialize</code> method of base actor until, according to the logic of the actor, initialization is finished.</p>
<p>Actor shutdown is reverse process: <code>supervisor</code> sends <code>shutdown_request</code> message (<code>on_shutdown</code>), the actor changes it's state to <code>SHUTTING_DOWN</code>, and initiates unsubscription for all subscriptions. The <code>supervisor</code> sends back <code>unsubscription_confirmation_t</code> to the actor; when there are no more subscriptions actor changes state to <code>SHUTTED_DOWN</code> and sends the confirmation to the supervisor address.</p>
<p>The approach makes it possible for external actors observe when observable actor changes state (<code>INITIALIZED</code>, <code>OPERATIONAL</code>, <code>SHUTTING_DOWN</code>, <code>SHUTTED_DOWN</code>) and react appropriately. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
